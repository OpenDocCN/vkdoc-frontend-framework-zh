# 四、查找 HTML 元素

您遇到过多少次这样的项目:仅仅使用 jQuery 来执行看似微不足道的元素选择？你写了多少次`$('#myElement')`或者`$('.myElement')`？如果您的大多数(或所有)项目都依赖于 jQuery，那么您可能没有意识到这样一个事实，即您不需要 jQuery 来选择元素！借助普通的 ole boring web API，这项任务相当简单。与 jQuery 非常相似，有大量的例子(如本书)展示了如何恰当地利用浏览器的能力来快速选择文档中的任何元素。所有这些都不是什么秘密，但是 jQuery 的普及性让许多人相信找到元素的唯一合理的方法是借助万能的美元符号。没有什么比这更偏离事实了，当你继续读下去，所有这些都会变得清晰。

这里描述的所有选择元素的方法在所有现代浏览器中都受支持。事实上，许多在古代浏览器中也受支持。换句话说，除非您正在支持一个老化的遗留 web 应用，否则即使是最复杂的用于选择元素的本地解决方案也可以在没有任何库的帮助下使用。对于那些仍然依赖于过去浏览器的旧应用来说呢？您可以用几行代码轻松复制任何缺少的本机方法。事实上，我将提供一些简单直观的解决方案来帮助您填补古代浏览器中的重要空白。

尽管 jQuery 确实为您节省了一些击键次数，但是您将会牺牲性能。这种类型的高级抽象比直接依赖原生 API 要慢，这是可以理解的。那么，如果您希望既有 jQuery 的便利性，又没有巨大的依赖性和潜在的性能问题，该怎么办呢？很简单，在 web API 周围创建你自己的非常薄的包装器来节省你的一些击键。在我们结束本章之前，我将用一些示例代码来探索这种可能性。

## 核心元素选择器

在关于在文档中查找 HTML 元素这一主题的第一部分中，我讨论了通过使用一些更传统的元素属性来选择元素，比如 ID、类和标记名。在这里，我通过例子比较了 jQuery 中的元素选择和“普通”JavaScript，这些例子利用各种 web API 规范中的功能直接与 DOM 交互。完成本节之后，您将有必要的信心和理解来使用最常见的方法在 DOM 中选择元素——完全不依赖 jQuery。

### 本能冲动

W3C HTML4 规范 [<sup>1</sup>](#Fn1) 将`id`属性定义为在文档内定义的所有 id 中必须是唯一的。规范的这一部分继续描述它的主要用途， [<sup>2</sup>](#Fn2) 比如元素选择和使用锚链接导航到页面的其他部分。DOM Level 1 规范定义了`HTMLElement`接口、 [<sup>3</sup>](#Fn3) ，所有其他元素都从该接口继承。在这个接口中定义了`id`属性，它直接连接到在标记中相应元素上定义的`id`属性。

例如，考虑以下标记:

```js
1  <div id="my-element-id"></div>

```

`<div>`元素的`id`属性也可以通过元素的 JavaScript 表示来访问。这是由元素对象的`id`属性公开的:

```js
1  // `theDiv` is the <div> from our sample HMTL above

2  theDiv.id === 'my-element-id'; // returns true

```

#### 框架

在 jQuery-land 中，获取`<div>`元素对象的句柄类似于清单 [4-1](#Par11) 。

```js
1  // returns a jQuery object with 1 element -

2  // the <div> from our sample HMTL above

3  var result = $('#my-element-id');
4
5  // assuming our element has been found in the document

6  result.is('#my-element-id'); // returns true

Listing 4-1.Select by ID: jQuery

```

在 jQuery 示例中，我们使用 ID 选择器字符串，它最初是在 W3C CSS1 规范中定义的。 [<sup>4</sup>](#Fn4) 这次选择尝试返回的 jQuery 对象是一个伪数组(第 [12 章](12.html)对此有更详细的讨论)。这个伪数组包含文档中这个元素的对象表示。

#### Web API

在没有 jQuery 帮助的情况下选择完全相同的元素非常容易，事实上实现这一点的代码看起来非常相似。使用 web API 通过 ID 选择元素有两种不同的方式。第一个这样的方法涉及到使用在`Document`接口上定义的`getElementById`方法，它首先在 DOM Level 2 Core 规范中正式化。 [<sup>5</sup>](#Fn5) 现有的所有浏览器都支持这种方法(最早在 Internet Explorer 5.5 中实现):

```js
1  // returns the matching HTMLElement - the <div> from our sample

2  var result = document.getElementById('my-element-id');
3
4  // assuming our element has been found in the document

5  result.id === 'my-element-id'; // returns true

```

第二种方法利用了`querySelector`方法，该方法首先在 W3C 选择器 API Level 1 规范中的文档和元素接口上定义。 [<sup>6</sup>](#Fn6) 记住定义了`id`属性的`HTMLElement`接口继承自`Element`接口，所以`Element` s 也有一个`id`属性。所有现代浏览器都有`querySelector`方法，包括 Internet Explorer 8。在清单 [4-2](#Par16) 中，您将开始注意到本地方法和 jQuery 快捷方式之间的一些明显的相似之处。

```js
1  // returns the matching HTMLElement - the <div> from our sample

2  var result = document.querySelector('#my-element-id');
3
4  // assuming our element has been found in the document

5  result.id === 'my-element-id'; // returns true

Listing 4-2.Select by ID: Web API, Modern Browsers and Internet Explorer 8

```

Performance Note

`querySelector`比`getElementById`、[、<sup>和</sup>、](#Fn7)稍慢，但是随着浏览器 JavaScript 引擎的发展，这种性能差距正在缩小。

### 班级

与 IDs 的关注点相反，类属性并不唯一地标识文档中的元素。相反，传统上使用类在应用的上下文中将元素作为一个整体进行语义分组。虽然 id 当然可以用于通过 CSS 设计元素的样式，但是这个角色通常与类属性联系在一起。元素也可以被分配多个类名，而它们只限于一个 ID(原因很明显)。HTML 4.01 规范对类属性的角色进行了更详细的描述。 [<sup>8</sup>](#Fn8) 第 [5](05.html) 章更详细地讨论了元素属性的使用。

一般来说，有效的 CSS 类不区分大小写，只能包含字母数字字符或连字符或下划线，并且不能以一个数字或两个连字符或一个连字符和一个数字开头。这些规则也适用于 id，以及用于通过 CSS 定位元素的其他元素属性。你可以阅读 CSS 2.1 规范中 CSS 选择器的所有允许值。 [<sup>9</sup>](#Fn9)

例如，考虑以下标记:

```js
1  <span class="some-class"></span>

```

通过对象的`className`属性上的元素的 JavaScript 表示，也可以访问`span`元素的`class`属性。注意这里的不一致性——属性名是`class`，而对应的`Element`属性是`className`。这是因为`class`是许多语言中的保留字，例如 JavaScript(甚至晚于 ECMAScript 5.1 版规范)， [<sup>10</sup>](#Fn10) 这就是为什么在元素的 JavaScript 表示中存在备用名称。例如:

```js
1  // `elementObject` is the <span> in our sample markup above

2  elementObject.className === 'some-class'; // returns true

```

#### 框架

在 jQuery 中按类选择元素看起来非常类似于用来选择 ID 的方法。事实上，jQuery 中的所有元素选择都遵循相同的模式:

```js
1  // Returns a jQuery object with 0 elements (element not found)

2  // or all elements with the 'some-class' class attribute.

3  var result = $('.some-class');
4
5  // assuming our element has been found in the document

6  result.is('.some-class'); // returns true

```

如果文档中碰巧有三个不同元素的类名为`some-class`，那么`result` jQuery 对象将有三个条目，每个条目对应一个匹配。

#### Web API

与 IDs 一样，使用 web API 通过类名选择元素有几种不同的方法。我将演示其中的两个——都可以在现代浏览器和 Internet Explorer 8 中使用(最后一个例子)。清单 [4-3](#Par28) 是性能最好的，但是清单 [4-4](#Par32) 显然是最优雅的。

```js
1  // Returns an HTMLCollection containing all matching elements,

2  // which is empty if there are no matches.

3  var result = anyElement.getElementsByClassName('some-class');
4
5  // assuming our element has been found in the document

6  result[0].className === 'some-class'; // returns true

Listing 4-3.Select by Class: Web API, Modern Browsers

```

`getElementById`和`getElementsByClassName`之间第一个值得注意的区别是，后者返回一个类似数组的对象，包含所有匹配的元素，而不是单个元素。记住，一个文档可以包含许多共享相同类名的元素。您可能还会注意到另一个差异，在提供的简单示例中，这个差异可能不是特别明显。`getElementsByClassName`方法在`Document`界面上可用，就像`getElementById`一样。但是，在 W3C DOM4 规范中，它也被定义为元素接口上的方法。 [<sup>11</sup>](#Fn11) 这意味着在文档中指定一个元素来查找类名匹配时，可以将查询限制在特定的元素子集。当在特定元素上执行时，只检查后代元素的匹配。这允许更集中和更有效的 DOM 遍历。

`getElementsByClassName`方法的返回值是一个 HTMLCollection，这是一个伪数组，它提供了有序的数字属性(0，1，2，.。。)，每个匹配元素一个，还有一个`length`属性和一些其他方法(用处有限)。一件`HTMLCollection`最显著的特点是它是一件活的收藏品。也就是说，它会自动更新，以匹配它所代表的 DOM 中的底层元素。例如，如果包含在返回的`HTMLCollection`中的一个元素从 DOM 中移除，那么它也将从范围内的任何`HTMLCollection`中移除。注意，getElementsByClassName 是在 W3C DOM4 规范中定义的。

第二种方法，如清单 [4-4](#Par32) 所示，通过类名选择元素，涉及到前面演示的`querySelector`的一个表亲。

```js
1  // Returns a NodeList containing all matching elements,

2  // which is empty if there are no matches.

3  var result = anyElement.querySelectorAll('.some-class');
4
5  // assuming our element has been found in the document

6  result[0].className === 'some-class'; // returns true

Listing 4-4.Select by Class: Web API, Modern Browsers and Internet Explorer 8

```

像`getElementsByClassName`，`querySelectorAll`在一个类似数组的对象中返回所有匹配。不过，差异也就到此为止了。例如，`querySelectorAll`返回一个`NodeList`对象，这是一个首先在 W3C DOM Level 3 核心规范中正式定义的接口。 [<sup>12</sup>](#Fn12) `NodeList`与`HTMLCollection`有一个重要的区别:它不是一个“活”的系列。因此，如果一个包含在`NodeList`中的匹配元素从 DOM 中移除，它不会从任何`NodeList`中移除。

根据 W3C 选择器 API,`querySelectorAll`在`Document`接口和`Element`接口上都是可用的(就像`getElementsByClassName`)。[<sup>13</sup>](#Fn13)`querySelector`方法也可以在查找具有特定类名的元素时使用，它将只返回第一个匹配的元素，这在某些情况下实际上可能是可取的。无论哪种情况，都必须传递 CSS 选择器字符串。在查找类名时，我们必须包含一个“.”前缀，它最早是在 CSS 1 规范中描述的， [<sup>14</sup>](#Fn14) ，尽管更多的细节包含在后来的 CSS 2.1 规范中。 [<sup>15</sup>](#Fn15) 虽然`getElementsByClassName`在 IE8 中不可用，但是您也可以通过简单地将 CSS 类选择器字符串传递给`querySelectorAll`方法，在浏览器中通过类名定位元素。

如果您必须支持 Internet Explorer 7 或更早的版本，通过类名选择元素的方法可能有点麻烦。因为这种类型的支持正在迅速失宠，所以我选择忽略丑陋且低效的遗留解决方案(jQuery 无论如何都必须依赖它)。你可以看看我维护的一个库是如何解决 [<sup>16</sup>](#Fn16) 支持古代浏览器的问题的。

### 元素标签

任何元素最基本的属性就是它的名字。早在 1993 年，由蒂姆·伯纳斯·李部分起草的 IETF HTML 规范中， [<sup>17</sup>](#Fn17) 一个有效的元素/标签名可以“由一个字母后跟多达 33 个字母、数字、句点或连字符组成”该规范继续说“名称不区分大小写”在这个文档中还定义了少量的元素，比如锚标记(`<a>`)、段落标记(`<p>`)和用于提供联系信息的`<address>`元素。自从这个第一个规范以来，已经添加了更多的元素，例如在相对较新的 HTML5 规范中添加的`<video>` [<sup>18</sup>](#Fn18) 和`<audio>`[<sup>19</sup>](#Fn19)。

尽管定制元素没有被浏览器明确禁止，但是在 Web 组件规范出现之前，没有什么动机去创建它们。 [<sup>20</sup>](#Fn20) Web Components 是一个规范集合，其中一个是自定义元素规范， [<sup>21</sup>](#Fn21) 详细说明了创建新的`HTMLElement`的方法，这些新的`HTMLElement`具有自己的 API 和属性，甚至是现有元素的扩展——例如 ajax 表单自定义元素， [<sup>22</sup>](#Fn22) 扩展并添加了原生`<form>`的功能。

为了设置我们的示例，考虑以下非常简单的 HTML 块:

```js
1  <code>System.out.println("Hello world!");</code>

```

如果给你一个元素引用，你可以通过`tagName`属性很容易地确定元素的名称，这个属性是在元素接口上定义的，是 DOM Level 1 Core 的一部分: [<sup>23</sup>](#Fn23)

```js
1  // `elementObject` is the <code> element from our above HTML

2  elementObject.tagName === 'code'; // returns true

```

#### 框架

可以预见的是，通过将 CSS 元素选择器传递到`$`或`jQuery`函数中，可以方便地通过 jQuery 选择元素:

```js
1  // Returns a jQuery object with 0 elements (element not found)

2  // or all elements with a matching tag name.

3  var result = $('code');
4
5  // assuming our element has been found in the document

6  result.is('code'); // returns true

```

这里没什么神奇的。事实上，元素名称选择器字符串的语法是在第一个 CSS 规范中定义的。jQuery 只是为本地方法提供了一个简单的别名，这些本地方法可以通过标签名来选择元素，接下来将对此进行探讨。

#### Web API

让我们从通过直接与本地 web API 交互来快速查看通过标记名选择元素的传统方法开始:

```js
1  // Returns a HTMLCollection containing all matching elements,

2  // which is empty if there are no matches.

3  var result = anyElement.getElementsByTagName('code');
4
5  // assuming our element has been found in the document

6  result[0].tagName === 'code'; // returns true

```

前面的方法早在 DOM Level 1 Core 就已经有了，而且和`getElementsByClass- Name`一样，在文档接口 [<sup>25</sup>](#Fn25) 和元素接口上都有。 [<sup>26</sup>](#Fn26) 所以，这种方法在现有的所有浏览器上都是可用的。

如你所料，更“现代”的方法包括`querySelector`或`querySelectorAll`:

```js
 1  // Returns a NodeList containing all matching elements,

 2  // which is empty if there are no matches.

 3  var result = anyElement.querySelectorAll('code');
 4
 5  // assuming our element has been found in the document

 6  result[0].tagName === 'code'; // returns true

 7
 8  // -OR-

 9
10  // ...you can use this if you know there is only one <code>

11  // element to find, or if you only care about the first.

12  // Returns true.

13  anyElement.querySelector('code').tagName === 'code';

```

目前在`getElementsByTagName`和`querySelectorAll(tagName)`之间存在潜在的显著性能差异。 [<sup>27</sup>](#Fn27) 使用`querySelectorAll`的性能后果显然是由于`getElementsByTagName`返回 DOM 中匹配元素的动态集合(一个 HTMLCollection)，而`querySelectorAll`返回静态集合(一个 NodeList)。后者需要遍历 DOM 中的所有元素，而前者返回缓存的匹配元素，然后在访问列表时查询文档更新。 [<sup>28</sup>](#Fn28) 这种性能差异类似于`getElementsByClassName`对`query- SelectorAll(classSelector)`出于同样的原因。

### 伪类

虽然在 CSS 规范的最新版本中，伪类的流行和数量有了很大的增长，但是伪类从 CSS 规范的最早版本就已经存在了。 [<sup>29</sup>](#Fn29) 伪类是向选择器字符串或元素组添加状态的关键字。例如，锚选择器字符串上的`:visited`伪类将指向用户已经访问过的任何链接。另一个例子是，`:focus`伪类将把被确定为具有焦点的元素作为目标，比如用户当前正在交互的文本输入字段。在下面的例子中，我们将使用后者，因为出于隐私考虑，浏览器会阻止 JavaScript 中的程序选择器访问被访问的链接。 [<sup>30</sup>](#Fn30)

为了设置我们的示例，让我们创建一个带有几个文本输入的简单表单，并假设用户点击了(或跳转到)最后一个文本输入(名为“company”)。这最后一个输入将是“聚焦”的输入:

```js
1  <form>
2     <label>Full Name
3        <input name="full-name">
4     </label>
5     <label>Company
6        <input name="company">
7     </label>
8  </form>

```

#### 框架

假设我们想使用 jQuery 选择当前关注的输入:

```js
1  // Return value will be a jQuery object containing the

2  // "company" input element

3  var focusedInputs = $('INPUT:focus');

```

前面同样是一个标准化的 CSS 选择器字符串。我们使用了一个带有伪类修饰符的标签名选择器。jQuery 并没有为我们做什么特别的事情。事实上，它只是简单地直接委托给 web API。

#### Web API

请考虑以下几点:

```js
1  // Return value will be the "company" text input field element

2  var companyInput = document.querySelector('INPUT:focus');

```

这段代码避免了所有与通过 jQuery 过滤调用相关的开销。如果我们使用 jQuery(就像我们在前面的例子中所做的那样),`querySelectorAll`将被 jQuery 的选择器代码用完全相同的选择器字符串在内部调用。由于一次只能有一个元素有焦点，`querySelector`比`querySelectorAll`更合适。它也更快一点，因为同样的原因，任何一种`getElementsBy`方法都比`querySelectorAll`快。

## 根据元素之间的关系选择元素

有了一些在头脑中记忆犹新的选择元素的基本方法，我们就可以通过元素选择器进入下一步了。以下部分介绍了如何根据元素与其他元素的关系来选择元素。我们将研究定位子元素和子元素、子元素的父元素以及其他元素的兄弟元素。DOM 被组织成树状结构。考虑到这一点，能够在考虑关系的情况下导航这种节点层次结构通常是有利的。正如我们在核心选择器一节中已经看到的那样，在没有 jQuery 的情况下，根据元素之间的关系查找元素相当简单，而且性能更好。

### 父母和孩子

从我们对 DOM API 的讨论中可以看出，`Element`是`Node`的一种特定类型。如果一个`Node`或`Element`是一个“叶”节点，那么它可以没有孩子。否则，它将有一个或多个直接子级。但是文档中的每个`Node`或`Element`都只有一个直接父级。嗯，差不多了。这个规则有两个例外:一个出现在`<html>`标签(`HTMLHtmlElement` ) [<sup>31</sup>](#Fn31) 中，它是文档中的根`Element`，因此没有父`Element`(尽管它有一个父`Node` : `document`)。这就把我们带到了第二个异常，即既没有父对象`Node`也没有父对象`Element`的`document`对象(`Document`)[<sup>32</sup>](#Fn32)。是根`Node`。

清单 4-5 显示了一个简单的 HMTL 片段。

```js
1  <div>
2     <a href="http://fineuploader.com">
3        <span>Go to Fine Uploader</span>
4     </a>
5     <p>Some text</p>
6     Some other text
7  </div>

Listing 4-5.Example Markup for Parent/Children Traversal Examples

```

在下面的代码示例中，将区分目标子/父`Node` s 和`Element` s。如果这种区分还不清楚，首先要理解清单 [4-5](#Par63) 是由`Element`类型对象组成的，例如`<div>`、`<a>`、`<span>`和`<p>`。这些`Element`也是`Node`，因为`Element`接口是`Node`接口的子类型。但是片段的“转到精细上传器”、“一些文本”和“一些其他文本”部分不是`Element`，但是它们是`Node`，更具体地说，它们是`Text`项。`Text`接口 [<sup>33</sup>](#Fn33) 是`CharacterData`接口 [<sup>34</sup>](#Fn34) 的一个子类型，它本身实现了`Node`接口。

#### 框架

jQuery 的 API 包括一个`parent`方法。为了简单起见，我们假设“当前 jQuery 对象”只表示一个元素。当在这个对象上调用`parent`方法时，产生的 jQuery 对象将包含父对象`Element`，或者在极少数情况下，包含不是`Element`的父对象`Node`。参见清单 [4-6](#Par66) 。

```js
 1  // Assuming $a is a reference to the anchor in our example HTML,

 2  // $result will contain the <div> above it.

 3  var $result = $a.parent();
 4
 5  // Assuming $span is a reference to the <span> in our example HTML,

 6  // the first parent() call references the <a> element, and the

 7  // $result will contain the <div> root element.

 8  var $result = $span.parent().parent();
 9
10  // Assuming someText is a reference to the "Some text" Text node,

11  // the result will contain the <p> element in our example HTML.

12  // Note: selecting a text node requires locating the node in the result of

13  // using the `contents()` method, as illustrated in the next code block.

14  var $result = $someText.parent();
Listing 4-6.
Get Parent Element/Node:

jQuery

```

为了定位子元素，jQuery 提供了一个`children()`方法，该方法将返回给定元素的所有直接子元素`Element`。您还可以使用 CSS 2.1 W3C 规范中标准化的子选择器选择给定引用元素的子元素。 [<sup>35</sup>](#Fn35) 但是由于`children()`只会返回`Element` s，所以我们必须使用 jQuery 的`contents()` API 方法来获取任何不同时属于`Element` s 的`Node` s，比如`Text`节点。同样，为了保持简单，清单 [4-7](#Par68) 假设我们示例中的引用 jQuery 对象只引用 DOM 中的一个特定元素。

```js
 1  // Assuming $div is a jQuery object containing the <div> in our example HTML,

 2  // $result will contain 2 elements: <a> and <p>.

 3  var $result = $div.children();
 4
 5  // $result contains the <p> element in the sample markup

 6  var $result = $('DIV > P');
 7
 8  // Again, assuming $div refers to the <div> in our example markup,

 9  // $result will contain 3 nodes: <a>, <p>, and "Some other text".

10  var $result = $div.contents();
11
12  // Assuming $a refers to the <a> element in our example markup,

13  // $result will contains 1 element: <span>.

14  var $result = $a.children();
15
16  // This returns the exact same elements as the previous example.

17  var $result = $('A > *')
Listing 4-7.Get Child Elements and/or Child Nodes: jQuery

```

#### Web API

在大多数情况下，不使用 jQuery 来定位元素/节点的父元素很简单。DOM Level 2 Core 是第一个在`Node`接口上定义一个`parentNode`属性的规范， [<sup>36</sup>](#Fn36) 正如您所料，它被设置为引用元素的父元素`Node`。当然，这个值可以是一个`Element`或任何其他类型的节点。后来，在随后的 W3C DOM4 规范中，一个`parentElement`属性被添加到了`Node`接口中。 [<sup>37</sup>](#Fn37) 这个属性永远是一个`Element`。如果引用`Node`的父级是除`Element`之外的某种类型的`Node`，那么`parentElement`将是`null`。但是大多数情况下，`parentElement`和`parentNode`会是相同的，除非参考节点是`<html>`，在这种情况下`parentNode`会是`document`，`parentElement`当然会是`null`。一般来说，特别是由于广泛的浏览器支持，`parentNode`属性是最好的选择，但是`parentElement`几乎一样安全。参见清单 [4-8](#Par70) 。

```js
 1  // Assuming "a" is the <a> element in our HTML example,

 2  // "result" will be the the <div> above it.

 3  var result = a.parentNode;
 4
 5  // Assuming "span" is the <span> element in our HTML example,

 6  // the first parentNode is the <a>, while "result" is the <div>

 7  // at the root of our example markup.

 8  var result = span.parentNode.parentNode;
 9
10  // Assuming "someText" is the "Some text" Text node in our HTML example,

11  // "result" will be the the <p> that contains it.

12  var result = someText.parentNode;
Listing 4-8.
Get Parent Element/Node:

Web API

```

使用 web API 有许多不同的方法来定位元素的直接子元素。接下来我将演示两种这样的方法，并简要讨论第三种方法。在所有现代浏览器中定位元素子元素的最简单也是最常见的方法是使用`ParentNode`接口上的`children`属性。 [<sup>38</sup>](#Fn38) `ParentNode`被定义为由`Element`和`Document`接口共同实现，尽管它通常只在`Element`接口上实现。它适用于可能有孩子的`Node`。它最初是在 W3C DOM4 规范 [<sup>39</sup>](#Fn39) 中定义的，只在现代浏览器中可用。`ParentNode.children`返回一个`HTMLCollection`中引用`Node`的所有子节点，您可能还记得本章前面的内容，它代表了一个`Element`的“活动”集合:

```js
1  // Assuming "div" is an Element object containing the <div> in our example HTML,

2  // result will contain an HTMLCollection holding 2 elements: <a> and <p>.

3  var result = div.children;

```

第二种用于定位孩子`Element` s 的方法包括使用`querySelectorAll`和 CSS 2 子选择器。这种方法允许我们支持 Internet Explorer 8，以及所有现代浏览器。记住，`querySelectorAll`返回一个`NodeList`，它不同于`HTMLCollection`，因为它是元素的“静态”集合。在这种情况下，集合包含父节点`Node`的所有`Element`子节点:

```js
1  // The result will contain a NodeList holding 2 elements: <a> and <p>

2  // from our HTML fragment above.

3  var result = document.querySelectorAll('DIV > *');
4
5  // The result will be all <p> children of the <div>, which, in this case

6  // is only one element: <p>Some text</p>.

7  var result = document.querySelectorAll('DIV > P');

```

使用 web API 选择孩子的第三个选项涉及到了`Node`接口上的`childNodes`属性。 [<sup>41</sup>](#Fn41) 这个属性是在最初的 W3C DOM Level 1 核心规范中声明的。 [<sup>42</sup>](#Fn42) 结果是所有浏览器都支持，甚至是古代的。属性`childNodes`将显示所有子节点`Node`，甚至`Text`和`Comment`节点。您可以简单地通过迭代结果来过滤掉集合中的非`Element`对象，忽略任何具有不等于`1`的`nodeType`属性 [<sup>43</sup>](#Fn43) 的对象。这个`nodeType`属性也是在最初的`Node`接口规范中定义的:

```js
1  // Assuming "div" is an Element object containing the <div> in

2  // our example HTML, result will contain a NodeList

3  // holding 3 Nodes: <a>, <p>, and "Some other text".

4  var result = div.childNodes;

```

给定一个父节点`Node`，你也可以分别通过恰当命名的`firstChild`和`lastChild`属性定位第一个和最后一个子节点。这两个属性在最初的`Node`接口规范中就已经存在，并且它们引用子`Node` s，所以第一个或最后一个子元素可能是`Text Node`或`HTMLDivElement`。`firstChild`属性可以作为第四种方法的一部分，用来获取父`Node`的子对象。这种方法将在下面的兄弟元素选择一节中讨论。

### 同科

如果它们共享同一个直系父代，那么它们就是兄弟姐妹。它们可能是相邻的兄弟姐妹(彼此紧挨着)或“一般的”兄弟姐妹(不一定紧挨着)。有多种方法可以在兄弟`Node`中查找和导航。虽然我将介绍如何使用 jQuery 来实现这一点以供参考，但是您将会看到在没有 jQuery 的情况下实现这一点是多么容易。清单 [4-9](#Par79) 将被用作所有演示代码的参考点。

```js
1  <div id="parent">
2     <a href="https://github.com/rnicholus">GitHub</a>
3     <span>Span text</span>
4     <p>Paragraph text</p>
5     <div>Div text</div>
6     Text node
7  </div>
Listing 4-9.Working with Siblings: Markup for Following Demos

```

#### 框架

为了找到给定`Element`的所有兄弟`Element`，jQuery 提供了一个`siblings`方法作为其 API 的一部分。对于遍历给定`Element`的兄弟节点，也有`next()`和`prev()`方法。为了简单起见，我将简单回顾一下我们是如何使用 jQuery 来查找和遍历给定元素的兄弟元素的，从清单 [4-10](#Par81) 开始。

```js
 1  // $result will be a jQuery object that contains <a>, <span>, <p>,

 2  // and <div> elements inside of the #parent <div>.

 3  var $result = $('SPAN').siblings();
 4
 5  // $result will be a jQuery object that contains the <a> element

 6  // that precedes the <span>.

 7  var $result = $('SPAN').prev();
 8
 9  // The first next() refers to the <p>, and the 2nd next()

10  // refers to the <div>Div text</div> element, which is also

11  // the element contained in the jQuery $result object.

12  var $result = $('SPAN').next().next();
13
14  // The first next() refers to the <p>, and the 2nd next()

15  // refers to the <div>Div text</div> element. The final next()

16  // does not reference any element, since the final Node in the

17  // fragment is a Text Node, and not an element. So, the $result

18  // is an empty jQuery object.

19  var $result = $('SPAN').next().next().next();
Listing 4-10.Find and Traverse Through Siblings: jQuery

```

您还可以在 jQuery 中使用 CSS 同级选择器，我们将在下一节中对此进行探讨。jQuery 实际上允许标准化的 W3C CSS 选择器字符串用于这一操作和其他操作。

#### Web API

为了反映 jQuery API 提供的行为，我将讨论以下与兄弟遍历和发现相关的主题:

1.  定位特定`Element`或`Node`的所有兄弟。
2.  浏览特定`Element`或`Node`的前面和后面的兄弟。
3.  使用 CSS 选择器定位一个`Element`的普通兄弟和相邻兄弟。
4.  使用`Node`接口上的兄弟属性定位子节点。

定位另一个`Element`的所有兄弟`Element`的最简单方法是使用 CSS3 通用兄弟选择器。 [<sup>44</sup>](#Fn44) 这种方法可以追溯到 Internet Explorer 8，并为您提供所有同级`Element`的`NodeList`，W3C CSS2 规范定义了一个“相邻”同级选择器， [<sup>45</sup>](#Fn45) ，它只选择与引用元素之后出现的选择器相匹配的第一个`Element`。清单 [4-11](#Par89) 展示了这里描述的两个兄弟选择器。

```js
 1  // "result" contains a NodeList of all siblings that occur after the <span>

 2  // in our example HMTL at the start of this section. These siblings are

 3  // the <p> and the <div> elements.

 4  var result = document.querySelectorAll('#parent > SPAN ∼ *');
 5
 6  // Another general sibling selector that specifically targets any

 7  // subsequent siblings of the <span> that are <div>s. In our case,

 8  // there is only one such element - <div>Div text</div>. The

 9  // "result" variable is a NodeList containing this one element.

10  var result = document.querySelectorAll('#parent > SPAN ∼ DIV');
11
12  // This is an adjacent sibling selector in action. It will target

13  // the first sibling after the <span>. So, "result", is the same

14  // as in the previous general sibling selector example.

15  var result = document.querySelector('#parent > SPAN + *');
Listing 4-11.
Find Siblings Using

CSS Selectors

: Web API, Modern Browsers, and Internet Explorer 8

```

您会注意到，通用同级选择器(∾)不选择引用元素之前的任何元素，只选择引用元素之后的元素。如果您确实需要考虑引用元素之前的任何兄弟元素，您将需要使用首先在 W3C DOM Level 1 Core[<sup>46</sup>](#Fn46)中定义的`Node.previousSibling`属性，或者使用首先在 W3C 元素遍历规范中定义的`ElementTraversal`接口 [<sup>47</sup>](#Fn47) 的一部分`previousElementSibling`属性。 [<sup>48</sup>](#Fn48)

`ElementTraversal`是由任何也实现了`Element`接口的对象实现的接口。简单地说，所有 DOM 元素都有一个`previousElementSibling`属性。清单 [4-12](#Par92) 展示了这一点。

```js
 1  // Find all siblings that follow the <span> in our example HTML

 2  var allSiblings = document.querySelectorAll('#parent > SPAN ∼ *');
 3
 4  // Converts the allSiblings NodeList into an Array.

 5  allSiblings = [].slice.call(allSiblings);
 6
 7  var currentElement = document.querySelector('#parent > SPAN');
 8
 9  // This loop executes until we run out of previous siblings,

10  // starting with the sibling before the <span>. Each sibling

11  // is added to the allSiblings array. After this loop is complete,

12  // the allSiblings array will contain all siblings of the <span>

13  // (before and after).

14  do {
15     currentElement = currentElement.previousElementSibling;
16     currentElement && allSiblings.unshift(currentElement);
17  } while (currentElement);
Listing 4-12.
Find Both Preceding and

Subsequent

Siblings of a Reference Element: Web API, Modern Browsers

```

Note

另一种方法是选择引用元素的父元素，然后收集其子元素，忽略引用元素。本节中的代码是专门为演示一些标准 CSS 选择器和元素属性而创建的。

对于 Internet Explorer 8 支持，您必须使用`Node.previousSibling`而不是`Element.previousElementSibling`。这是因为在 9 以前的任何版本的 Explorer 中都不支持元素遍历规范。该属性返回任何`Node`，因此如果您只想接受`Element` s，您将需要确保添加一个`nodeType`属性检查。参见清单 [4-13](#Par94) 。

```js
 1  var allSiblings = document.querySelectorAll('#parent > SPAN ∼ *');
 2
 3  // Converts the allSiblings NodeList into an Array.
 4  var allSiblings = [].slice.call(allSiblings);
 5
 6  var currentElement = document.querySelector('#parent > SPAN');
 7
 8  do {
 9    currentElement = currentElement.previousSibling;
10    // This differs from the previous example in that we must

11    // exclude non-Element Nodes by examining the nodeType property.

12    if (currentElement && currentElement.nodeType === 1) {
13      allSiblings.unshift(currentElement);
14    }
15  } while (currentElement);
Listing 4-13.
Find Both Preceding and Subsequent Siblings of a Reference Element: Web API, Modern Browsers, and Internet Explorer

8

```

web API 还在`Node`接口上公开了一个`nextSibling`属性，在`ElementTraversal`接口上公开了一个`nextElementSibling`属性。 [<sup>49</sup>](#Fn49) 如清单 [4-14](#Par96) 所示，浏览器对这些属性的支持与它们“以前的”表亲相同。

```js
 1  // The first nextSibling refers to the <p>, and the 2nd nextSibling

 2  // refers to the <div>Div text</div> element. The final nextSibling

 3  // refers to the "Text node" Text Node, since nextSibling targets

 4  // any type of Node. So, the result is this Text Node.

 5  var result = document.querySelector('SPAN')
 6                  .nextSibling.nextSibling.nextSibling;
 7
 8  // Same as the above example, but the final nextElementSibling returns null,

 9  // since the last Node in the example markup is not an Element. There are only

10  // 2 Element siblings following the <span>. Note that nextElementSibling

11  // is not available in ancient browsers.

12  var result = document.querySelector('SPAN')
13                  .nextElementSibling.nextElementSibling.nextElementSibling;
Listing 4-14.Traverse Through All Subsequent Siblings:  Web API, Modern Browsers, and Internet Explorer 8

```

除了上一节概述的使用 web API 选择孩子的方法之外，还有另一个这样的选项，在任何浏览器中只选择父`Node`的`Element`孩子。这包括获取父元素`Node`的`firstChild`，定位第一个子元素的兄弟元素`Node`，然后使用每个`Node`的`nextSibling`属性继续遍历所有兄弟元素，直到没有剩余的兄弟元素。最后，为了排除所有非元素的兄弟元素(比如`Text Node` s)，只需检查每个`Node`的`nodeType`属性，如果`Node`更具体地说是一个`Element`，那么这个属性的值就是`1`。这就是 jQuery 实现其`children`方法的方式，至少在库的 1.x 版本中是这样。这种实现选择可能是因为`Node`接口上的所有这些属性都有广泛的浏览器支持，甚至在古老的浏览器中。然而，现代浏览器支持更简单的方法，所以刚刚描述的路径实际上仅从学术或历史角度相关。

### 祖先和后代

为了说明祖先/后代`Node`的关系，让我们从一个简短的 HTML 片段开始:

```js
 1  <body>
 2     <div>
 3        <span>random text</span>
 4           <ul>
 5              <li>
 6                 <span>item 1</span>
 7              </li>
 8              <li>
 9                 <a href="#some-content">item 2</a>
10              </li>
11           </ul>
12     </div>
13  </body>

```

一个元素的祖先是在 DOM 中出现在它之前的任何元素。也就是说，它的父母、其父母的父母(或祖父母)、其父母的父母的父母(曾祖父母)，等等。在前面的 HTML 片段中，锚元素的祖先包括它的直接父元素(`<li>`)，以及`<ul>`、`<div>`，最后是`<body>`元素。相反，一个元素的后代包括它的子元素、子元素的子元素等等。在前面的标记中，`<ul>`元素有四个后代:两个`<li>`元素、`<span>`和`<a>`。

#### 框架

jQuery 的 API 提供了一种方法来检索元素的所有祖先- `parents()`:

```js
1  // Using our HTML example, $result is a jQuery object that

2  // contains the following elements: <li>, <ul>,

3  // <div>, and <body>

4  var $result = $('A').parents();

```

但是，如果您只想检索匹配特定条件的第一个祖先，该怎么办呢？在我们的例子中，假设我们只寻找也是一个`<div>`的`<a>`的第一个祖先。为此，我们将使用 jQuery 的`closest()`方法。jQuery 通过强力实现`closest()`——通过检查引用`Node`的每个父节点:

```js
1  // Using our HTML example, $result is a jQuery object that

2  // contains the <div> element.

3  var $result = $('A').closest('DIV');

```

为了定位后代，您可以使用 jQuery 的`find()`方法:

```js
1  // Using our HTML example, $result is a jQuery object that

2  // contains the following elements: both <li>s, the <span>,

3  // and the <a>.

4  var $result = $('UL').find('*');
5
6  // $result is a jQuery object that contains the <span>

7  // under the first <li>.

8  var $result = $('UL').find('SPAN');

```

#### Web API

原生 web 不提供返回元素所有祖先的单一 API 方法。如果你的项目需要这样做，你可以利用`Node.parentNode`属性 [<sup>50</sup>](#Fn50) 或`Node.parentElement`，通过一个简单的循环来累积这些`Node`。记住，后者只针对一种特定类型的`Node`:一种`Element`。这通常是我们想要的，所以我们将在例子中使用`parentElement`。参见清单 [4-15](#Par108) 。

```js
 1  // When this code is complete, "ancestors" will contain all

 2  // ancestors of the anchor element: <li>, <ul>,

 3  // <div>, and <body>

 4  var currentNode = document.getElementsByTagName('A')[0],
 5      ancestors = [];
 6
 7  while (currentNode.parentElement) {
 8     ancestors.push(currentNode.parentElement);
 9     currentNode = currentNode.parentElement;
10  }
Listing 4-15.
Retrieve All Element Ancestors:

Web API

, Any Browser

```

我们已经知道，jQuery 提供了一种方法，允许我们轻松地找到元素的第一个匹配祖先，`closest`。web API 在`Element`接口上有类似的方法，也叫`closest. Element.closest()` [<sup>51</sup>](#Fn51) 是 WHATWG DOM“生活标准”的一部分。 [<sup>52</sup>](#Fn52) 这个方法的行为和 jQuery 的`closest()`完全一样。截至 2016 年年中，任何版本的 Internet Explorer 和 Microsoft Edge 都不支持这种方法，但 Chrome、Firefox 和 Safari 9 支持这种方法。在下一个例子中，我将演示如何使用 web API 的`closest()`方法，我甚至为没有本机支持的浏览器提供了一个简单的后备。让我们再次使用我们的示例标记，并尝试定位`<a>`的最近祖先，即`<div>`。参见清单 [4-16](#Par111) 和 [4-17](#Par112) 。

Note

你可能还记得第 3 章的内容，WHATWG 开发了一套网络规范，与传统的 W3C 规范略有不同。

```js
1  function closest(referenceEl, closestSelector) {
 2    // use Element.closest if it is supported

 3    if (referenceEl.closest) {
 4        return referenceEl.closest(closestSelector);
 5    }
 6
 7    // ...otherwise use brute force (like jQuery)

 8    // To find a match for our closestSelector, we must use the

 9    // Element.matches method, which is still vendor-prefixed

10    // in some browsers.

11    var matches = Element.prototype.matches ||
12          Element.prototype.msMatchesSelector ||
13          Element.prototype.webkitMatchesSelector,
14
15        currentEl = referenceEl;
16
17    while (currentEl) {
18      if (matches.call(currentEl, closestSelector)) {
19        return currentEl;
20      }
21      currentEl = currentEl.parentElement;
22    }
23
24    return null;
25  }
26
27  // "result" is the <div> that exists before the <a>

28  var result = document.querySelector('A').closest('DIV');
Listing 4-16.

Retrieve Closest Element Ancestor

: Web API, All Modern Browsers Except IE and Edge

```

```js
 1  function closest(referenceEl, closestSelector) {
 2    // use Element.closest if it is supported

 3    if (referenceEl.closest) {
 4        return referenceEl.closest(closestSelector);
 5    }
 6
 7    // ...otherwise use brute force (like jQuery)

 8
 9    // To find a match for our closestSelector, we must use the

10    // Element.matches method, which is still vendor-prefixed

11    // in some browsers.

12    var matches = Element.prototype.matches ||
13          Element.prototype.msMatchesSelector ||
14          Element.prototype.webkitMatchesSelector,
15
16        currentEl = referenceEl;
17
18    while (currentEl) {
19      if (matches.call(currentEl, closestSelector)) {
20        return currentEl;
21      }
22      currentEl = currentEl.parentElement;
23    }
24
25    return null;
26  }
27
28  // "result" is the <div> that exists before the <a>

29  var result = closest(document.querySelector('A'), 'DIV');

Listing 4-17.Retrieve Closest Element Ancestor: Web API, All Modern Browsers

```

请注意，跨浏览器解决方案使用了`Element.matches`、[、 <sup>53</sup> 、](#Fn53)，这也是 WHATWG 在其 DOM living 规范中定义的。如果调用该方法的元素与传递的 CSS 选择器匹配，该方法将返回`true`。一些浏览器，即 IE 和 Safari，仍然实现与旧版本规范一致的命名约定以及特定于供应商的前缀。我已经在我的例子中说明了这些。

前面的解决方案可能不够优雅，但它更好地利用了浏览器的固有功能。jQuery 的`closest()`函数总是使用最原始的蛮力方式，即使浏览器原生支持`Element.closest`。

使用 web API 查找后代就像使用 jQuery 一样简单(清单 [4-18](#Par116) )。

```js
1  // Using our HTML example, result is a NodeList that

2  // contains the following elements: the two <li>s, <span>,

3  // and <a>.

4  var result = document.querySelectorAll('UL *');
5
6  // "result" is a NodeList that contains the <span>

7  // under the first <li>.

8  var result = document.querySelectorAll('UL SPAN');
Listing 4-18.

Retrieve Element Descendants

: Web API, Modern Browsers, and Internet Explorer 8

```

## 掌握高级元素选择

下面是一些更高级的方法，用于选择更具体的元素或元素组。虽然 jQuery 提供了 API 方法来处理每种场景，但是您会看到现代 web 规范也提供了相同的支持，这意味着对于这些示例，在现代浏览器中不需要 jQuery。这里的 Web API 解决方案将主要涉及各种 CSS3 选择器的使用， [<sup>54</sup>](#Fn54) 也可以从 jQuery 中使用。

所有现代浏览器都支持本节中的所有本地示例。在某些情况下，我还会谈到如何在古老的浏览器中使用 web API 来实现相同的目标。如果您发现自己需要以下一些选择器来支持一个古老的浏览器，那么在理解如何使用浏览器的本地工具来解决这个问题之后，您可能会放弃引入 jQuery。或者不是，但至少该解决方案将揭示 jQuery 的内部工作原理，如果您坚持将其作为核心工具集的一部分，这仍然是有益的。

### 排除元素

尽管排除集合中特定匹配的能力是 jQuery API 的一部分，但是我们还将看到如何使用另一个适当命名的伪类来获得相同的结果。在我们深入研究代码之前，让我们考虑下面的 HTML 片段:

```js
1  <ul role="menu">
2     <li>choice 1</li>
3     <li class="active">choice 2</li>
4     <li>choice 3</li>
5  </ul>

```

想象这是某种菜单，有三个项目可供选择。第二个项目“选项 2”当前被选中。如果您想方便地收集所有未选中的菜单项，该怎么办？

#### 框架

jQuery 的 API 提供了一个`not()`方法，该方法将从原始元素集中删除任何匹配选择器的元素:

```js
1  // $result is a jQuery object that contains all

2  // `<li>`s that are not "active" (the first and last).

3  var $result = $('UL LI').not('.active');

```

虽然前面的例子是惯用的 jQuery，但是您不必使用`not()`函数。相反，您可以使用 CSS3 选择器，这将在下面讨论。

#### Web API

现代浏览器的原生解决方案可以说和 jQuery 的一样优雅，当然也一样简单。下面，我们使用 W3C CSS3 否定伪类 [<sup>55</sup>](#Fn55) 来定位非活动列表项。没有库开销，所以这当然比 jQuery 的实现更有性能:

```js
1  // "result" is a NodeList that contains all

2  // `<li>`s that are not "active" (the first and last).

3  var result = document.querySelectorAll('UL LI:not(.active)');

```

但是如果我们仍然需要支持 Internet Explorer 8，不幸的是它不支持否定伪类选择器呢？好吧，这个解决方案并不优雅，但是如果我们需要一个快速的解决方案并且不想引入一个大的库，这个解决方案也不是特别困难:

```js
 1  var allItems = document.querySelectorAll('UL LI'),
 2      result = [];
 3
 4  // "result" will be an Array that contains all

 5  // `<li>`s that are not "active" (the first and last).

 6  for (var i = 0; i < allItems.length; i++) {
 7     if (allItems[i].className !== 'active') {
 8        result.push(allItems[i]);
 9     }
10  }

```

前面的解决方案仍然比 jQuery 实现的`not()`方法性能更好。 [<sup>56</sup>](#Fn56)

### 多重选择器

假设您想要选择几组不同的元素。考虑下面的 HTML 片段:

```js
1  <div id="link-container">
2     <a href="https://github.com/rnicholus">GitHub</a>
3  </div>
4  <ol>
5     <li>one</li>
6     <li>two</li>
7  </ol>
8  <span class="my-name">Ray Nicholus</span>

```

如果您想选择“link-container”和“my-name”元素以及有序列表，该怎么办？我们还假设您想要在没有循环的情况下完成这一任务——只需一行简单的代码。

#### 框架

jQuery 允许您通过提供一个长的逗号分隔的 CSS 选择器字符串来选择多个不相关的元素:

```js
1  // $result is a jQuery object that contains 3 elements -

2  // the <div>, <ol> and the <span> from this section's

3  // HTML fragment.

4  var $result = $('#link-container, .my-name, OL');

```

#### Web API

使用 web API，不使用 jQuery 也可以获得完全相同的结果。该解决方案看起来与 jQuery 解决方案极其相似。在这种情况下以及许多其他情况下，jQuery 只是 web API 的一个非常薄的包装器。jQuery 完全支持并充分利用 CSS 规范。选择多个不相关的元素组的能力一直是 CSS 规范的一部分。由于 jQuery 支持标准的 CSS 选择器字符串，所以 jQuery 方法看起来与本地路径几乎相同:

```js
1  // "result" is a NodeList that contains 3 elements -

2  // the <div>, <ol> and the <span> from this section's

3  // HTML fragment.

4  var result = document.querySelectorAll('#link-container, .my-name, OL');

```

### 元素类别和修饰符

jQuery 的 API 提供了不少自己专有的 CSS 伪类选择器，比如`:button`、`:submit`和`:password`。事实上，jQuery 的文档建议不要使用这些非标准选择器，因为事实上还有更高性能的选择——标准化的 CSS 选择器。例如，`:button`伪类的 jQuery API 文档包含以下警告:

*   因为:button 是一个 jQuery 扩展，不是 CSS 规范的一部分，所以使用:button 的查询无法利用原生 DOM querySelectorAll()方法提供的性能提升。

我将演示如何使用`querySelectorAll`模拟 jQuery 自己的一些伪类的行为。这些解决方案(如清单 [4-19](#Par140) 和 [4-20](#Par140) 所示)将比使用非标准的 jQuery 选择器更高效。我们将从`:button`、`:submit`、`:password`和`:file`开始。

```js
1  // "result" will contain a NodeList of all <button> and

2  // <input type="button"> elements in the document, just like

3  // jQuery's :button pseudo-class.

4  var result = document.querySelectorAll('BUTTON, INPUT[type="button"]');
1  // "result" will contain a NodeList of all <button type="submit"> and

2  // <input type="submit"> elements in the document, just like

3  // jQuery's :submit pseudo-class.

4  var result = document.querySelectorAll(
5          'BUTTON[type="submit"], INPUT[type="submit"]'
6      );
Listing 4-19.Implementing jQuery’s :button Pseudo-class: Web API, Modern Browsers, and Internet Explorer 8

```

清单 [4-21](#Par142) 和 [4-22](#Par143) 中的原生解决方案有点冗长，但并不特别复杂，而且肯定比 jQuery 的`:submit`性能更好。你可以看到相同的性能差异`between jQuery’s :button`选择器和本机解决方案更多: [<sup>58</sup>](#Fn58)

```js
1  // "result" will contain a NodeList of all <input type="password">

2  // elements in the document, just like jQuery's :password pseudo-class.

3  var result = document.querySelectorAll('INPUT[type="password"]');
Listing 4-21.Implementing jQuery’s :password Pseudo-class: Web API, Modern Browsers, and Internet Explorer 8

```

```js
1  // "result" will contain a NodeList of all <input type="file">

2  // elements in the document, just as jQuery's :file pseudo-class.

3  var result = document.querySelectorAll('INPUT[type="file"]');
Listing 4-22.

Implementing jQuery’s

:file Pseudo-class: Web API, Modern Browsers, and Internet Explorer 8

```

甚至这个相当简单的原生 CSS 选择器也比 jQuery 的非标准`:file`伪类快得多。 [<sup>59</sup>](#Fn59) 性能损失真的值得你在代码里省几个字符吗？

jQuery 还提供了一个非标准的`:first`伪类选择器。如您所料，它会过滤查询结果集中除第一个匹配之外的所有匹配。考虑以下标记:

```js
1  <div>one</div>
2  <div>two</div>
3  <div>three</div>

```

假设我们想要选择这个片段中的第一个`<div>`。使用 jQuery，我们的代码看起来会像这样:

```js
1  // $result is a jQuery object containing

2  // the first <div> in our example markup.

3  var $result = $('DIV:first');
4
5  // same as above, but perhaps more idiomatic jQuery.

6  var $result = $('DIV').first();

```

与 jQuery 的原始实现相比，本机解决方案出奇地简单，而且性能异常出色:

```js
1  // result is the first <div> in our example markup.

2  var result = document.querySelector('DIV');

```

由于`querySelector`返回选择器字符串的第一个匹配，这实际上是 jQuery 的`:first`伪类或`first()` API 方法的一个非常优雅的替代方法。在 jQuery 的武库中，您会发现许多其他专有的 CSS 选择器，它们在 web API 中有直接的替代方法。

## $(选择器)的简单替换

在本章中，您已经看到了许多元素选择方法，包括将 CSS 选择器字符串传递给`jQuery`函数(别名为`$`)。本地解决方案通常包含传递给`querySelector`或`querySelectorAll`的相同选择器字符串。在所有条件相同的情况下，假设我们只使用有效的 CSS 选择器字符串，我们可以用一个本地解决方案来替换 jQuery 函数，这个本地解决方案不仅易于连接，而且比 jQuery 性能更高。

如果我们只关注选择器支持，并且只需要对现代浏览器的支持，我们可以通过完全放弃 jQuery 并用一个令人惊讶的简洁的本地替代来代替它，如清单 [4-23](#Par154) 所示。

```js
1  window.$ = function(selector) {
2     return document.querySelectorAll(selector);
3  };
4
5  // examples that use our replacement

6  $('.some-class');
7  $('#some-id');
8  $('.some-parent > .some-child');
9  $('UL LI:not(.active)');
Listing 4-23.Native Replacement for jQuery Function: All Modern Browsers, Internet Explorer 8 for CSS2 Selectors

```

当对比使用 jQuery 和 web API 选择这些相同的元素时，一些更复杂的选择器中看到的性能优势存在的原因与前面描述的相同。让我们看看上面代码中的子选择器。我们的原生解决方案无疑比 jQuery、 [<sup>61</sup>](#Fn61) 更快，并且两者之间的语法完全相同。在这里，我们没有因为放弃 jQuery 而放弃任何东西，并且获得了性能和更精简的页面——这是本章值得注意的主题。

Footnotes [1](#Fn1_source)

[T2`www.w3.org/TR/REC-html40/cover.html`](http://www.w3.org/TR/REC-html40/cover.html)

  [2](#Fn2_source)

[T2`www.w3.org/TR/REC-html40/struct/global.html#adef-id`](http://www.w3.org/TR/REC-html40/struct/global.html#adef-id)

  [3](#Fn3_source)

[T2`www.w3.org/TR/REC-DOM-Level-1/level-one-html.html#ID-58190037`](http://www.w3.org/TR/REC-DOM-Level-1/level-one-html.html#ID-58190037)

  [4](#Fn4_source)

[T2`www.w3.org/TR/REC-CSS1/#id-as-selector`](http://www.w3.org/TR/REC-CSS1/#id-as-selector)

  [5](#Fn5_source)

[T2`www.w3.org/TR/DOM-Level-2-Core/core.html#ID-getElBId`](http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-getElBId)

  [6](#Fn6_source)

[T2`www.w3.org/TR/selectors-api/#queryselector`](http://www.w3.org/TR/selectors-api/#queryselector)

  [7](#Fn7_source)

[T2`http://jsperf.com/getelementbyid-vs-queryselector/11`](http://jsperf.com/getelementbyid-vs-queryselector/11)

  [8](#Fn8_source)

[T2`www.w3.org/TR/html401/struct/global.html#adef-class`](http://www.w3.org/TR/html401/struct/global.html#adef-class)

  [9](#Fn9_source)

[T2`www.w3.org/TR/CSS21/syndata.html#characters`](http://www.w3.org/TR/CSS21/syndata.html#characters)

  [10](#Fn10_source)

[T2`www.ecma-international.org/ecma-262/5.1/#sec-7.6.1.2`](http://www.ecma-international.org/ecma-262/5.1/#sec-7.6.1.2)

  [11](#Fn11_source)

[T2`www.w3.org/TR/2015/WD-dom-20150428/#dom-document-getelementsbyclassname`](http://www.w3.org/TR/2015/WD-dom-20150428/#dom-document-getelementsbyclassname)

  [12](#Fn12_source)

[T2`www.w3.org/TR/DOM-Level-3-Core/core.html#ID-536297177`](http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-536297177)

  [13](#Fn13_source)

[T2`www.w3.org/TR/2007/WD-selectors-api-20071221/#documentselector`](http://www.w3.org/TR/2007/WD-selectors-api-20071221/#documentselector)

  [14](#Fn14_source)

[T2`www.w3.org/TR/REC-CSS1/#class-as-selector`](http://www.w3.org/TR/REC-CSS1/#class-as-selector)

  [15](#Fn15_source)

[T2`www.w3.org/TR/CSS21/selector.html#class-html`](http://www.w3.org/TR/CSS21/selector.html#class-html)

  [16](#Fn16_source)

[T2`https://github.com/FineUploader/fine-uploader/blob/5.2.1/client/js/util.js#L107`](https://github.com/FineUploader/fine-uploader/blob/5.2.1/client/js/util.js#L107)

  [17](#Fn17_source)

[T2`www.w3.org/MarkUp/draft-ietf-iiir-html-01.txt`](http://www.w3.org/MarkUp/draft-ietf-iiir-html-01.txt)

  [18](#Fn18_source)

[T2`www.w3.org/TR/html5/embedded-content-0.html#the-video-element`](http://www.w3.org/TR/html5/embedded-content-0.html#the-video-element)

  [19](#Fn19_source)

[T2`www.w3.org/TR/html5/embedded-content-0.html#the-audio-element`](http://www.w3.org/TR/html5/embedded-content-0.html#the-audio-element)

  [20](#Fn20_source)

[T2`www.w3.org/wiki/WebComponents/`](http://www.w3.org/wiki/WebComponents/)

  [21](#Fn21_source)

[T2`www.w3.org/TR/custom-elements/`](http://www.w3.org/TR/custom-elements/)

  [22](#Fn22_source)

[T2`https://github.com/rnicholus/ajax-form`](https://github.com/rnicholus/ajax-form)

  [23](#Fn23_source)

[T2`www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-1950641247`](http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-1950641247)

  [24](#Fn24_source)

[T2`www.w3.org/TR/REC-CSS1/#basic-concepts`](http://www.w3.org/TR/REC-CSS1/#basic-concepts)

  [25](#Fn25_source)

[T2`www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#i-Document`](http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#i-Document)

  [26](#Fn26_source)

[T2`www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-745549614`](http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-745549614)

  [27](#Fn27_source)

[T2`https://jsperf.com/queryselectorall-vs-getelementsbytagname`](https://jsperf.com/queryselectorall-vs-getelementsbytagname)

  [28](#Fn28_source)

[T2`www.nczonline.net/blog/2010/09/28/why-is-getelementsbytagname-faster-that-queryselectorall/`](http://www.nczonline.net/blog/2010/09/28/why-is-getelementsbytagname-faster-that-queryselectorall/)

  [29](#Fn29_source)

[T2`www.w3.org/TR/CSS1/#anchor-pseudo-classes`](http://www.w3.org/TR/CSS1/#anchor-pseudo-classes)

  [30](#Fn30_source)

[T2`www.w3.org/TR/selectors-api/#privacy`](http://www.w3.org/TR/selectors-api/#privacy)

  [31](#Fn31_source)

[T2`www.w3.org/TR/html5/semantics.html#the-html-element`](http://www.w3.org/TR/html5/semantics.html#the-html-element)

  [32](#Fn32_source)

[T2`www.w3.org/TR/html5/dom.html#the-document-object`](http://www.w3.org/TR/html5/dom.html#the-document-object)

  [33](#Fn33_source)

[T2`www.w3.org/TR/DOM-Level-3-Core/core.html#ID-1312295772`](http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-1312295772)

  [34](#Fn34_source)

[T2`www.w3.org/TR/DOM-Level-3-Core/core.html#ID-FF21A306`](http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-FF21A306)

  [35](#Fn35_source)

[T2`http://www.w3.org/TR/CSS21/selector.html#child-selectors`](http://www.w3.org/TR/CSS21/selector.html#child-selectors)

  [36](#Fn36_source)

[T2`www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1060184317`](http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1060184317)

  [37](#Fn37_source)

[T2`www.w3.org/TR/2015/WD-dom-20150428/#node`](http://www.w3.org/TR/2015/WD-dom-20150428/#node)

  [38](#Fn38_source)

[T2`www.w3.org/TR/2015/WD-dom-20150428/#parentnode`](http://www.w3.org/TR/2015/WD-dom-20150428/#parentnode)

  [39](#Fn39_source)

[T2`www.w3.org/TR/2015/WD-dom-20150428/`](http://www.w3.org/TR/2015/WD-dom-20150428/)

  [40](#Fn40_source)

[T2`http://www.w3.org/TR/CSS21/selector.html#child-selectors`](http://www.w3.org/TR/CSS21/selector.html#child-selectors)

  [41](#Fn41_source)

[T2`www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-1950641247`](http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-1950641247)

  [42](#Fn42_source)

[T2`www.w3.org/TR/REC-DOM-Level-1/level-one-core.html`](http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html)

  [43](#Fn43_source)

[T2`www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-1950641247`](http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-1950641247)

  [44](#Fn44_source)

[T2`www.w3.org/TR/css3-selectors/#general-sibling-combinators`](http://www.w3.org/TR/css3-selectors/#general-sibling-combinators)

  [45](#Fn45_source)

[T2`www.w3.org/TR/CSS21/selector.html#adjacent-selectors`](http://www.w3.org/TR/CSS21/selector.html#adjacent-selectors)

  [46](#Fn46_source)

[T2`www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-1950641247`](http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-1950641247)

  [47](#Fn47_source)

[T2`www.w3.org/TR/ElementTraversal/#attribute-previousElementSibling`](http://www.w3.org/TR/ElementTraversal/#attribute-previousElementSibling)

  [48](#Fn48_source)

[T2`www.w3.org/TR/ElementTraversal/`](http://www.w3.org/TR/ElementTraversal/)

  [49](#Fn49_source)

[T2`www.w3.org/TR/ElementTraversal/#attribute-nextElementSibling`](http://www.w3.org/TR/ElementTraversal/#attribute-nextElementSibling)

  [50](#Fn50_source)

[T2`www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1060184317`](http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1060184317)

  [51](#Fn51_source)

[T2`https://dom.spec.whatwg.org/#dom-element-closestselectors`](https://dom.spec.whatwg.org/#dom-element-closestselectors)

  [52](#Fn52_source)

[T2`https://dom.spec.whatwg.org`](https://dom.spec.whatwg.org)

  [53](#Fn53_source)

[T2`https://dom.spec.whatwg.org/#dom-element-matchesselectors`](https://dom.spec.whatwg.org/#dom-element-matchesselectors)

  [54](#Fn54_source)

[T2`www.w3.org/TR/css3-selectors/`](http://www.w3.org/TR/css3-selectors/)

  [55](#Fn55_source)

[T2`www.w3.org/TR/css3-selectors/#negation`](http://www.w3.org/TR/css3-selectors/#negation)

  [56](#Fn56_source)

[T2`http://jsperf.com/jquery-not-vs-looping-through-results1`](http://jsperf.com/jquery-not-vs-looping-through-results1)

  [57](#Fn57_source)

[T2`www.w3.org/TR/REC-CSS1/#grouping`](http://www.w3.org/TR/REC-CSS1/#grouping)

  [58](#Fn58_source)

[T2`http://jsperf.com/jquery-submit-vs-queryselectorall`](http://jsperf.com/jquery-submit-vs-queryselectorall)

  [59](#Fn59_source)

[T2`http://jsperf.com/jquery-file-vs-queryselectorall`](http://jsperf.com/jquery-file-vs-queryselectorall)

  [60](#Fn60_source)

[T2`http://jsperf.com/jquery-first-vs-queryselector`](http://jsperf.com/jquery-first-vs-queryselector)

  [61](#Fn61_source)

[T2`http://jsperf.com/jquery-select-children-vs-native-replacement`](http://jsperf.com/jquery-select-children-vs-native-replacement)