# 十二、常见的 JavaScript 工具函数

在第十二章中，我计划将 jQuery 的实用函数 <sup>1</sup> 与 ECMAScript 规范中定义的本地 API 进行匹配。本章中的大部分代码都可以在浏览器和服务器上运行(除了例子中的`DOMParser`和任何对`window`或`document`的引用)。在现代浏览器中，jQuery 大部分时间都是不必要的。但是，即使 jQuery 节省了一些击键次数，能够运行自己的实用函数也是很重要的，即使您选择引入一个库来实现一些更复杂、支持更少的特性。毕竟，理解 jQuery 如何发挥其魔力会让您成为一名更全面、更有效的软件开发人员。

jQuery 可能会提供本章没有详细介绍的其他实用函数，但是我会介绍所有“重要”的函数。首先，我演示并解释了 jQuery 提供的处理字符串、日期、XML 和 JSON 的函数是如何在没有任何外部库的情况下复制的。接下来，我转到对检查变量类型有用的代码。例如，确定一个值是`Object`、`Array`、`Function`还是某个特定的原始值。不要担心，我稍微详细说明了原始值，以防您不完全熟悉 JavaScript 中可用的每个原始值类型。jQuery 确实提供了检测值类型的函数。我回顾了这些，并向您展示了如何用普通 JS 执行相同的类型检查(以及更多的检查)。

我还解释了操作、创建和遍历对象以及数组。最后，我们一起来搞清楚函数——也就是说，如何在没有 jQuery 的 JavaScript 函数上执行各种重要且常见的操作。完成这一章后，你会觉得自己处理 JavaScript 对象、函数、数组和原语更加得心应手，不需要任何“外部”帮助。

## 使用日期、文本、XML 和 JSON

第一部分考虑在普通的传统 JavaScript 中复制 jQuery 的`Date`和 string helper 函数的行为。但不仅仅是普通的字符串，JSON 和 XML 也是如此。尽管 jQuery 使得使用日期和字符串执行简单、常见的任务变得非常容易，但是您很快就会看到这个库在这个上下文中是多么不必要。

### 日期

jQuery 并不真正关注日期，尽管它可能贡献了一些有价值的实用函数，使一些更有用的`Date`原型方法在跨浏览器时更加可靠。例如，`Date.prototype`提供了许多方法，可以用来根据特定的地区设置特定日期的格式，比如`Date.prototype.toLocaleString()`和`Date.prototype.toLocateDateString()`。尽管这在当前的地区得到了很好的支持，但是传递可变地区的能力目前还没有得到浏览器的支持。此外，这些方法还允许根据一组特定的要求对日期进行格式化。假设您希望使用全名(而不是数字或缩写)打印当前月份。只需将一个选项对象(第二个参数)作为`{month: 'long'}`传递给`toLocaleString()`。但是，即使在现代浏览器中，这也没有得到很好的支持。

不，jQuery 不能帮助我们解决 JavaScript 中任何真正的`Date`相关问题。相反，它只提供了一个方法来返回自 Unix 纪元(00:00:00 UTC，1970 年 1 月 1 日)以来的毫秒数。假设当前时间是 2016 年 6 月 4 日午夜。如果我们调用 jQuery 提供的这个实用函数来获得自 Unix 纪元以来的毫秒数，会怎么样呢？代码会是什么样子？

```js
1  var currentTime = $.now();

```

在任何浏览器中，不使用 jQuery 也可以获得相同的值，只需要多几个字符:

```js
1  var currentTime = new Date().getTime();

```

两个代码块中的`currentTime`变量是相同的(假设两行在完全相同的时间点执行)。自从 ECMAScript 规范的第一个版本 <sup>2</sup> 第一版% 2C 1997 年 6 月. pdf)以来，`getTime()`方法就在`Date.prototype`上可用。但是，如果我们只依赖现代浏览器，即使没有 jQuery 也可以更优雅地进行同样的调用:

```js
1  var currentTime = Date.now();

```

在 ECMAScript 规范的 5.1 版本中，`now()`函数被添加到了`Date`对象中。 <sup>3</sup> 事实上，最近版本的 jQuery 将`$.now()`直接连接到`Date.now()`。 <sup>4</sup> 但是，即使您非常不幸地需要支持古老的浏览器(也许是在一个不会消亡的遗留 web 应用中)，正如您已经看到的，只需很少的额外工作，就可以实现相同的行为。

### 将 JSON 转换成 JavaScript 对象

在 jQuery 1 . 4 . 1 版本中，引入了一个 API 方法来解析 JSON 字符串，将其转换成适当的 JavaScript 表示形式(`String`、`Number`、`Boolean`、`Object`或`Array`)。1.4.1 发布于 2010 年，比 Internet Explorer 8 发布晚了一年(后者能够原生解析 JSON 字符串)。然而，IE7 仍在使用，IE6 在某种程度上也是如此，两者都不能轻松地将 JSON 转换成 JavaScript。jQuery 的`parseJSON()`方法旨在使这项任务在所有支持的浏览器中成为可能。考虑以下简单的 JSON 字符串:

```js
1  {
2    "name": "Ray",
3    "id": 123
4  }

```

前面的 JSON 字符串作为一个`jsonString`变量对我们的代码可用，当然，它是一个`string`。可以使用 jQuery 的`$.parseJSON()`方法将这个 JSON 字符串转换成 JavaScript 对象:

```js
1  var user = $.parseJSON(jsonString);
2
3  // prints "Ray"

4  console.log(user.name);
5
6  // prints 123

7  console.log(user.id);

```

虽然`$.parseJSON()`确实提供了一种优雅的方式将 JSON 字符串转换成合适的 JavaScript 值，但是多年来它一直是一种完全不必要的抽象。所有现代浏览器和 Node.js 的所有版本(以及前面提到的 Internet Explorer 8)都支持`JSON`对象，该对象首先包含在 ECMAScript 5.1 中。 <sup>5</sup> 这里是没有 jQuery 的完全相同的解决方案:

```js
1  var user = JSON.parse(jsonString);
2
3  // prints "Ray"

4  console.log(user.name);
5
6  // prints 123

7  console.log(user.id);

```

如果浏览器支持`JSON`对象，jQuery 甚至会将所有 JSON 字符串解析工作交给`JSON.parse()`。除了解析 JSON 字符串，本地的`JSON`对象还可以通过`stringify()`方法将 JavaScript 值转换成字符串。jQuery 的 API 中没有这样的抽象，以前也没有。

对于比 Internet Explorer 7 更早的浏览器(包括 Internet Explorer 7 ),至少有一种方法可以在不访问本地方法的情况下解析 JSON 字符串。最常见的方法是使用本机`eval()`函数将 JSON 字符串解析成 JavaScript 值。尽管这确实可行，但由于使用`eval()`的安全隐患，这是一个众所周知的坏主意。使用`eval()`盲目地将字符串解析成 JavaScript 值需要执行底层代码。对于用户提供的字符串，这可能会导致灾难性的后果。为了应对这一现实，道格拉斯·克洛克福特在 2007 年创建了一个库——JSON . js<sup>6</sup>——也委托给了`eval()`，但只是在验证了`evaluate`的字符串是“安全的”之后。不管怎样，这些都不再需要了，因为不支持`JSON`的浏览器并没有被广泛使用。

### 将 XML 字符串转换为文档

与将 JSON 字符串转换成 JavaScript 表示的`$.parseJSON()`类似，jQuery 也在其公共 API 中定义了一个`parseXML()`方法。jQuery 的`$.parseXML()`将一个 XML 字符串转换成一个`document`。这使您能够使用 jQuery 的选择器 API 来查询文档，就像查询 HTML 文档一样。例如，考虑一个直接向 Microsoft Azure REST API 端点发出请求的应用。如果 URL 包含无效的查询参数，Azure 服务将在响应中使用以下 XML 字符串进行响应: <sup>7</sup>

```js
1  <?xml version="1.0" encoding="utf-8"?>

2  <Error>

3    <Code>InvalidQueryParameterValue</Code>

4    <Message>Value for one of the query parameters specified in the request URI is\
5   invalid.</Message>

6    <QueryParameterName>popreceipt</QueryParameterName>

7    <QueryParameterValue>33537277-6a52-4a2b-b4eb-0f905051827b</QueryParameterValue>

8    <Reason>invalid receipt format</Reason>

9  </Error>

```

我为这一部分选择了 Azure 响应，因为我清楚地记得在将“upload to Azure”功能集成到 Fine Uploader 时处理 XML 字符串浏览器端的解析，Fine Uploader 必须解析响应，并报告错误代码和消息以供显示和记录。 <sup>8</sup>

假设我们想做同样的事情——提取错误消息的`<Code>`和`<Message>`部分。我们当然可以使用正则表达式自己解析字符串，但这不是一种理想的方法。目标是将 XML 字符串转换成适当的文档，使用 jQuery 很容易做到这一点:

```js
1  // assuming we have the above XML string assigned to a var

2  var errorDocument = $.parseXML(azureErrorXmlString);
3
4  // code = "InvalidQueryParameterValue"

5  var code = $(errorDocument).find('Code').text();
6
7  // message = "Value for one of the query parameters..."

8  var message = $(errorDocument).find('Message').text();

```

注意，jQuery 实际上确实返回了一个`document`作为`$.parseXML()`的返回值，所以如果我们想要使用 jQuery 的 API 来解析文档，我们必须自己包装它。

您可能很高兴知道，我们可以在没有 jQuery 的所有现代浏览器中非常容易地完成所有这些工作:

```js
1  // assuming we have the above XML string assigned to a var

2  var errorDocument = new DOMParser()
3    .parseFromString(azureErrorXmlString, 'application/xml');
4
5  // code = "InvalidQueryParameterValue"

6  var code = errorDocument.querySelector('Code').textContent;
7
8  // message = "Value for one of the query parameters..."

9  var message = errorDocument.querySelector('Message').textContent;

```

虽然相同的解决方案在古代浏览器中不那么优雅，但在今天这真的不是问题。`DOMParser`接口被定义为 W3C DOM 解析和序列化规范 <sup>9</sup> 的一部分，该规范于 2012 年首次起草，截至 2016 年年中仍被列为“草案”。但是该文档中描述的行为已经在所有现代浏览器中实现了一段时间。这个特殊的规范旨在标准化已经在广泛的浏览器中实现的行为，类似于 CSS 对象模型规范。 <sup>10</sup>

也许您在对自己说，“为什么我必须包含 XML MIME 类型(application/xml)？”jQuery 的`parseXML()`方法不要求包含这个。答案很简单，根据本机解析器的通用名称，答案可能已经很明显了。`DOMParser`不仅仅是为了解析 XML 字符串而创建的。虽然这是目前支持最广泛的文档类型，但也支持将 SVG 字符串解析为 SVG 元素(image/svg+xml)和解析 HTML (text/html)。除了 Internet Explorer 9 之外，所有现代浏览器都支持后两种文档类型。`DOMParser`比 jQuery API 中的任何单一产品都要强大得多，而且它有潜力在未来扩展以支持更多类型。

### 字处理

令人惊讶的是，一个看似重要且常见的字符串操作任务——从一行文本的开头和结尾修剪空白——直到 ECMAScript 5.1 才作为一种 JavaScript 方法得到支持。<sup>11</sup>Internet Explorer 9 是实现本规范中定义的`String.prototype.trim()`方法的最老的浏览器。`trim()`的姗姗来迟解释了 jQuery 从 1.0 版本开始提供自己的`trim()`方法的一个主要原因。接下来的三个清单比较了 jQuery API 方法、`String.protoype.trim()`原生方法和一个针对古代浏览器的变通方法:

```js
1  // trimmed = 'some name'

2  var trimmed = $.trim(' some name ');
Listing 12-1.Trim a String: jQuery

```

```js
1  // trimmed = 'some name'

2  var trimmed = (' some name ').trim();
Listing 12-2.Trim a String: JavaScript, Modern Browsers

```

```js
1  // trimmed = 'some name'

2  var trimmed = (' some name ').replace(/^\s+|\s+$/g, '');
Listing 12-3.Trim a String: JavaScript, All Browsers

```

对于没有本地实现`String.prototype.trim()`的浏览器，解决方法需要求助于正则表达式。前面的解决方法包含在 Fine Uploader 的许多跨浏览器工具方法中的一个方法中(这是必需的，因为该库过去一直支持 Internet Explorer 6 之类的浏览器。 <sup>12</sup>

`$.` `trim()`是 jQuery 提供的唯一与字符串相关的便利方法。你可以在 Mozilla Developer Network 的`String`接口页面上阅读 JavaScript 提供的其他字符串操作和解析方法。 <sup>13</sup> 但这不会是我们在本章中最后一次深入探讨弦乐。

## 这是一种什么样的价值观？

JavaScript 的 ECMAScript 语言规范定义了两种通用数据类型:`Object`和原语。从第七版标准开始，共有六种原始数据类型:`null`、`undefined`、`Boolean`、`Number`、`String`和`Symbol`。就非原始类型而言，`Object`是一个，所有其他此类类型都继承自`Object`。有许多复杂的 JavaScript 类型继承自`Object. Array`和`Function`就是两个这样的例子。有些类型比其他类型更容易被可靠地识别，但是所有的值都可以在没有第三方库的帮助下被识别。然而，即使您已经依赖这样一个库，本节也将帮助您理解您的库可能使用的一些逻辑，以便确定 JavaScript 值类型。由于这本书主要面向已经熟悉 jQuery 及其便利的 API 方法集合的开发人员，因此我将主要关注 jQuery 提供的现有解决方案，向您展示如何在 JavaScript 中识别值类型。

### 基元

jQuery 提供了两个 API 方法，可以用来解析原始值:`$.isNumeric()`和`$.` `type()`。`type()` API 方法提供了最有用和最期望的行为。它将返回一个单字(小写)字符串，标识所提供值的 JavaScript 类型。例如:

```js
 1  // true

 2  $.type(3) === 'number';
 3
 4  // true

 5  $.type('3') === 'string';
 6
 7  // true

 8  $.type(null) === 'null';
 9
10  // true

11  $.type(undefined) === 'undefined';
12
13  // true

14  $.type(false) === 'boolean';
15
16  // true (only supported in Chrome, Firefox, and Safari)

17  $.type(Symbol('mysymbol')) === 'symbol';

```

jQuery 的`type()`方法也会为不常见的值产生预期的结果，如下所示:

```js
1  // true

2  $.type(new Number(3)) === 'number';
3
4  // true

5  $.type(new String('3')) === 'string';
6
7  // true

8  $.type(new Boolean(false)) === 'boolean';

```

尽管使用构造函数创建`String`、`Number`或`Boolean`是完全合法的，但这并不常见，而且这种做法并没有带来真正的好处。这也使得以这种方式构造的两个原语之间的比较变得困难。例如:

```js
 1  // both are true

 2  3 === 3;
 3  3 == 3;
 4
 5  // all are false

 6  3 === new Number(3);
 7  new Number(3) === new Number(3);
 8  new Number(3) == new Number(3);
 9
10
11  // both are true

12  'string' === 'string';
13  'string' == 'string';
14
15  // all are false

16  'string' === new String('string');
17  new String('string') === new String('string');
18  new String('string') == new String('string');
19
20
21  // both are true

22  false === false;

23  false == false;

24
25  // all are false

26  false === new Boolean(false);
27  new Boolean(false) === new Boolean(false);
28  new Boolean(false) == new Boolean(false);

```

事实上，除非在`Boolean`实例上调用`valueOf()`方法，否则用`Boolean`构造函数创建的布尔值在条件中总是计算为`true`。 <sup>14</sup> 多么直观啊！

那么，在没有 jQuery 的情况下，我们如何进行相同的原语类型比较呢？事实是，这些操作在所有浏览器中都是微不足道的(无论是现代的还是古代的)。看一看:

```js
 1  // true

 2  typeof 3 === 'number';
 3
 4  // true

 5  typeof '3' === 'string';
 6
 7  // true

 8  typeof undefined === 'undefined';
 9
10  // true

11  typeof false === 'boolean';
12
13  var someVal = null;

14  // true

15  someVal === null;

16
17  // true (only supported in Chrome, Firefox, and Safari)

18  typeof Symbol('mysymbol') === 'symbol';

```

在所有情况下，除了一种情况，我们可以利用`typeof`关键字来提供与 jQuery 的`type()`方法完全相同的结果。`typeof`从 JavaScript 的第一个版本开始就已经是语言的一部分了。然而，自从这个第一版以来也存在一个小问题，这可以在用`typeof`关键字评估`null`时看到:

```js
1  // false

2  typeof null === 'null';
3
4  // 'object'

5  typeof null;

```

如你所见，`typeof`认为`null`是一个`Object`，奇怪的是。这在很大程度上被认为是 JavaScript 最初实现中的一个错误，出于向后兼容的原因，这个错误一直存在。但是 ECMAScript-262 语言规范提供了另一种解释。`null`值 <sup>15</sup> 的定义被描述为“表示任何对象值有意缺失的原始值”在这方面，称这种类型为“对象”可能是恰当的。当我们看`typeof NaN`的结果时，这个理论更有意义，它评估为“数”。当然，如果`Number`的反义词评估为“数字”，那么有理由认为`Object`的反义词评估为“对象”。就一致性而言，这非常有意义(至少对我来说)。不过，你可以自由地形成自己的观点。不管怎样，这种行为可能永远不会改变，因为解决这个问题的提议在过去已经被否决了。 <sup>16</sup>

jQuery 的`$.isNumeric()`方法呢？嗯，这有点奇怪，或者至少最初看起来是这样。看一看:

```js
1  // all true

2  $.isNumeric(3);
3  $.isNumeric('3');
4
5  // all false

6  $.isNumeric(NaN);
7  $.isNumeric(Infinity);

```

换句话说，如果一个值确实是一个`Number`或者可以被强制为一个`Number`，那么 jQuery 的`isNumeric()`将返回`true`。所谓“强制”，我的意思是像“3”这样的字符串可以很容易地转换成合适的`Number`，例如，通过将它传递到`parseInt()`。此外，通过使用双等号(`==`)将字符串转换为`Number`作为比较操作的一部分，可以将该字符串评估为合适的`Number`，以便与另一个值进行比较。此外，确实是`Number` s 但通常不被认为是“数字”的值(如`NaN`和`Infinity`)在被传入`$.isNumeric()`时会产生一个`false`返回值。在没有 jQuery 的情况下实现同样的行为需要一点思考(也许还要谷歌一下)。但是，在意识到我们在评估自己的价值时需要做出两个决定之后，我们就可以找到解决方案:

1.  难道是`NaN`？
2.  是有限值吗？

诚然，大多数问题不太可能达到明确必须回答这两个具体问题的地步，但事实仍然是，这确实是我们需要确定的。幸运的是，从第一个版本开始，语言中就定义了两种方法，这两种方法可以让我们很容易地模仿 jQuery 的`isNumeric()`的行为:

```js
 1  function isNumeric(maybeNumber) {
 2    return !isNaN(parseFloat(maybeNumber))
 3              && isFinite(maybeNumber);
 4  }
 5
 6  // all true

 7  isNumeric(3);
 8  isNumeric('3');
 9
10  // all false

11  isNumeric(NaN);
12  isNumeric(Infinity);

```

当确定一个值是否为`NaN`时，需要添加`parseFloat`来正确评估`null`值。换句话说，如果`maybeNumber`是`null`，而我们忽略了`parseFloat()`，那么`isNaN()`将计算为`false`，并且`null`值将被错误地声明为“数字”。

### 数组

在所有的浏览器中，判断一个值是否是一个数组是很简单的事情，但是现代浏览器对这种判断的支持是非常优雅的。为此，我们有`Array.isArray()`:

```js
1  // both are true

2  Array.isArray([]);
3  Array.isArray(new Array());
4
5  // both are false

6  Array.isArray(3);
7  Array.isArray({});

```

在 ECMAScript-262 5.1 中，JavaScript `Array`对象被赋予了一个`isArray()`方法。 <sup>17</sup> 而 jQuery 在相当一段时间内也包含了类似的便利方法:`$.isArray()`:

```js
1  // both are true

2  $.isArray([]);
3  $.isArray(new Array());
4
5  // both are false

6  $.isArray(3);
7  $.isArray({});

```

但是从 2.0 开始的所有版本的 jQuery 在所有情况下都直接委托给本机`Array.isArray()`。换句话说，`$.isArray()`只是`Array.isArray()`的别名。旧版本的 jQuery 也委托给了`Array.isArray()`，但是是有条件的。如果`Array.isArray()`不可用(在古代浏览器中会出现这种情况)，jQuery 的`type`方法用于确定值是否是一个“数组”但是我们可以复制相同的行为，支持所有没有 jQuery 的浏览器，甚至是古老的浏览器:

```js
 1  function isArray(value) {
 2    return Array.isArray
 3    ? Array.isArray(value)
 4    : Object.prototype.toString.call(value) === '[object Array]';
 5  }
 6
 7  // both are true

 8  isArray([]);
 9  isArray(new Array());
10
11  // both are false

12  isArray(3);
13  isArray({});

```

请记住，上述代码只有在您计划支持非常旧的浏览器(如 Internet Explorer 8)时才有用。否则，`Array.isArray()`涵盖了所有可能的情况。但是让我们仔细看看上面例子的一部分，特别是`Object.prototype.toString.call(value)`。你可能想知道为什么我们不在这里简单地使用`typeof`。有点令人惊讶的是，`typeof []`和`typeof new Array()`产生一个结果“对象”。这在技术上是正确的——`Array`是`Object`的一种类型，因为它从`Object.prototype`继承而来,“object”的类型值没有预期的那么具体。当然，更有效的结果是“数组”。但是，可悲的是，事实并非如此。

将 JavaScript 数组视为带有一些方便方法的对象通常会有所帮助。这或多或少是事实。深入数组，您会发现数组元素访问遵循与对象属性访问相同的模式。例如，访问数组中的第三个元素:`myArray[2]`。并访问对象`myObject[2]`中名为`2`的属性。数组大多只是具有一些便利方法和一个`length`属性的对象，`typeof`反映了这一现实。通过使用`call()`方法调用`Object`原型上可用的`toString()`方法，这允许我们将`toString()`调用的上下文更改为数组文字，我们能够看到数组的“真实”类型。如果你对`call`方法感到困惑，也不用担心。我在这一章的结尾会谈到这个问题。

### 目标

对象不是原始数据类型，部分原因是对象是可变的，而原始数据类型在大多数编程语言中通常是不可变的。但是 JavaScript 中的对象类型是所有非原始值的基本类型。函数是对象，数组也是对象！关于这两种值类型的更多内容。

在 JavaScript 中，对象只是键/值属性的“集合”。键可以是字符串，也可以是整数(被转换成字符串)，甚至是`Symbol` s(如果浏览器支持这种原始数据类型)。任何东西都是有效的属性值，甚至是另一个对象。

jQuery 的`type` API 方法当然可以告诉我们一个值何时是对象，就像原生的`typeof`关键字一样。但是请记住前面的章节中的`typeof null === 'object'`和`typeof [] === 'object'`。这些值被`$.type()`标识为“null”和“array ”,这可能是您希望和期望的行为。那么，我们如何创建一个简单的跨浏览器函数，将任何“真实的”对象识别为一个对象，而忽略“数组对象”呢？这可以通过以下方式实现:

```js
 1  function isObject(value) {
 2    return value !== null &&
 3      Object.prototype.toString.call(value) === '[object Object]';
 4  }
 5
 6  // both are true

 7  isObject({});
 8  isObject(new Object());
 9
10  // both are false

11  isObject(null);
12  isObject([]);

```

除了`$.type()`，jQuery 还有一些更有趣的方法用来识别特定种类的 JavaScript 对象。一个是`$.isPlainObject()`，它应该确定一个特定的值是一个对象文字(`{}`)还是一个基本的`Object`实例(`new Object()`)。jQuery 的`type()`方法在这种情况下并不合适，因为它会将 DOM 元素识别为对象(这在技术上是正确的)。尽管理论上`isPlainObject()`很有用，但在我的整个职业生涯中，我很少需要做出这样的决定。此外，jQuery 的文档警告说，这种方法可能不可靠，可能会在某些浏览器中产生意想不到的结果。出于这些原因，我不打算进一步关注这个特定的 API 方法。可以说，如果您需要可靠地确定一个值是否是一个对象文字，您可能会发现重构您的问题是一个更好的途径。

jQuery 的`isEmptyObject()`是另一个有趣的方法，有更多实际的用例。您经常会遇到这样的情况:您被传递了一个对象，并且需要确定该对象是否包含任何属性。也许“空”对象表示在查询 API 时没有可用的数据。jQuery 的`isEmptyObject()`方法满足了这一需求:

```js
1  // true

2  $.isEmptyObject({});
3
4  // false

5  $.isEmptyObject({name: 'Ray'});

```

对于所有浏览器，有一个简单(虽然不那么优雅)的解决方案可以在没有 jQuery 的情况下做出相同的决定。查看 jQuery 的`isPlainObject()`实现，我们可以提取这个逻辑并为我们自己的项目创建一个微小的可重用函数，而不需要引入整个库:

```js
 1  function isEmptyObject(value) {
 2    for (property in value) {
 3      return false;

 4    }
 5    return true;

 6  }
 7
 8  // true

 9  isEmptyObject({});
10
11  // false

12  isEmptyObject({name: 'Ray'});

```

### 功能

除了一个特殊的例外，无论有没有 jQuery，函数都很容易识别。jQuery 提供了两种 API 方法，允许您确定 JavaScript 值是否是函数。一个是`$.type()`，我已经在本节演示过几次了。另一个是`$.isFunction()`，它简单地委托给`$.type()`，实际上使它成为一个别名:

```js
 1  // all true

 2  $.isFunction(function() {});
 3  $.type(function() {}) === 'function';
 4  $.isFunction(Object.prototype.toString);
 5  $.isFunction(document.body.getAttribute);
 6
 7  // all false

 8  $.isFunction({});
 9  $.type({}) === 'function';
10  $.isFunction(3);

```

JavaScript 中的标准`typeof`操作符产生完全相同的结果:

```js
1  // all true

2  typeof function() {} === 'function';
3  typeof Object.prototype.toString === 'function';
4  typeof document.body.getAttribute === 'function';
5
6  // all false

7  typeof {} === 'function';
8  typeof 3 === 'function';

```

甚至 JavaScript 类也被 jQuery 和`typeof`操作符识别为“函数”。这并不奇怪，因为 JavaScript 中没有“类”类型。ECMAScript 2015 类只不过是“语法糖”——一种创建从另一个对象继承的对象的更简单的方法。

jQuery 实际上不执行任何魔法来确定一个值是否是一个函数。这是真的，当试图在带有和不带有 jQuery 的古老浏览器中识别 web API 函数时，会产生意想不到的结果。早期版本的 Internet Explorer(版本 8 及更早版本)将标准 web API 函数误报为对象，例如那些在`Element`和`Window`接口上定义的函数。比如在 ie 8 中，`$.isFunction(document.body.getAttribute)`是`false`，同样是`typeof document.body.getAttribute === 'function'`。显然这是一个函数，但 IE 似乎认为它是一个“对象”。这并非完全不正确——毕竟，函数是对象。他们继承自`Object.prototype`。它们有时甚至被称为“功能对象”

## 让 JavaScript 对象屈从于你的意愿

正如您在上一节中了解到的，JavaScript 中的所有非原语值都继承自`Object`。这使得`Object`成为处理复杂数据时需要理解的最重要的值类型。一旦您能够将一个值识别为一个`Object`——这是您在上一节中学到的——理解如何在没有任何第三方代码帮助的情况下复制、解析和创建对象是很有帮助的。在这里，我将向您展示 jQuery 如何允许您对对象执行各种重要而有用的操作，以及如何通过使用 JavaScript 提供的标准方法来获得完全相同的结果。在大多数情况下，与 jQuery 的 API 相比，这些“本地”解决方案同样或类似地优雅。但是当然，有些操作会无可否认地显示出 jQuery 的优雅。尽管如此，即使涵盖与基于库的解决方案相比似乎不太理想的原生解决方案也有很大的价值。本节中的所有代码将让你对 JavaScript 有更深入的了解，这反过来会给你更多的信心，让你成为一个更强大、更有能力的开发人员。毕竟这是 Beyond jQuery 的首要目标。

### 遍历键和值

让我们从一个包含许多属性的对象开始:

```js
1  var user = {
2    name: 'Ray Nicholus',
3    address: '1313 Mockingbird Lane',
4    city: 'Mockingbird Heights',
5    state: 'California'
6  };

```

。。。我们有一个 HTML 表单需要接收这些值:

```js
1  <form>
2    <input name='name'>
3    <input name='address'>
4    <input name='city'>
5    <input name='state'>
6  </form>

```

如您所见，每个表单字段在我们的初始对象中都有一个匹配的属性。这个特定的对象可能由 AJAX 调用提供，我们必须简单地获取结果对象数据，并用匹配的值填充表单。假设您事先对表单或对象一无所知，只知道对象将具有与表单字段上的`name`属性相匹配的属性，并且这些表单字段可以使用它们的`value`属性进行更新。这要求我们做到以下几点:

*   循环访问对象中的属性
*   将匹配的`<input>`的`value`设置为等于对象属性值

在前面的章节中，你已经学习了如何使用 HTML 元素。在这里，我将向您展示如何遍历对象的属性，这样您就可以不用 jQuery 轻松解决这个问题。但是首先，让我们看看 jQuery 的解决方案:

```js
1  $.each(user, function(property, value) {
2    $('form [name="' + property + '"]').val(value);
3  });

```

没有现代浏览器的 jQuery 和 IE8，我们可以很容易地解决这个问题:

```js
1  for (var property in user) {
2    var value = user[property];
3    document.querySelector('FORM [name="' + property + '"]').value = value;
4  }

```

我们正在使用标准的`for...in`循环，这一直是语言的一部分。我们的代码“限于”Internet Explorer 8 和更新版本的唯一原因是因为使用了`querySelector`，但这似乎是一个合理的变通。请注意，在这种情况下，我们可以确保我们的对象只包含在该对象上定义的属性，而不包含在继承对象上定义的任何属性。但是如果这是一个问题，并且您只想检索专门属于这个`user`对象的属性，那么您将需要使用一个额外的检查，您的代码将如下所示:

```js
1  for (var property in user) {
2    if (user.hasOwnProperty(property)) {
3      var value = user[property];
4      document.querySelector('FORM [name="' + property + '"]').value = value;
5    }
6  }

```

每个`Object`上都有的`hasOwnProperty()`方法告诉我们一个给定的属性是否只属于源对象。从 ECMAScript 规范的第三版开始，它就成为了语言的一部分，所以在所有浏览器中使用它都是非常安全的。同样，在我们的例子中，这不是我们需要使用的东西，但是您可能会发现它在其他情况下很有用。

您可能会问自己，“为什么我没有在前面的 jQuery 例子中使用`hasOwnProperty()`”答案是:你有！jQuery 的`each()` API 方法在遍历对象属性时不调用`hasOwnProperty()`。已经确定 call 在所有情况下在库中使用都太昂贵了，并且将这种“增强”添加到现有方法实现中所需的工作太多了。不幸的是，`$.each()`的文档页面没有提醒用户他们可能不得不自己使用`hasOwnProperty()`的事实。

JavaScript 提供了另一种迭代对象属性的标准方法，还有一个额外的好处:不需要`hasOwnProperty()` (ever):

```js
1  Object.keys(user).forEach(function(property) {
2    var value = user[property];
3    document.querySelector('FORM [name="' + property + '"]').value = value;
4  });

```

前面的代码使用了`Object.keys()`，这是一种将对象中的所有属性转换成数组的方法。ECMAScript 5.1 中的`Object`增加了这个方法， <sup>19</sup> 在所有现代浏览器中都有。然后我们在所有的`Array`对象上使用可用的`forEach()`方法。下一节将详细介绍这个属性，但它也受到所有现代浏览器的支持。的确，这仍然比 jQuery 解决方案多一行(我告诉过你，不要担心代码行！)，但是它消除了调用`hasOwnProperty()`的需要，这最终可能会节省一些代码(如果你仍然关心这类事情的话)。

### 复制和合并对象

稍微扩展一下前面的例子，假设我们有关于同一个用户的两组非常不同的信息，我们需要将其中一组组合到另一组中，以形成包含所有用户数据的单个对象。我们的两个物体看起来像这样:

```js
 1  var userLocation = {
 2    name: 'Ray Nicholus',
 3    address: '1313 Mockingbird Lane',
 4    city: 'Mockingbird Heights',
 5    state: 'California'
 6  };
 7
 8  var userPersonal = {
 9    name: 'Ray Nicholus',
10    sex: 'male',
11    age: 35
12  };

```

我们想要的是一个对象——`user`——包含来自`userLocation`和`userPersonal`对象的所有属性。组合后的对象需要看起来像这样:

```js
1  var user = {
2    name: 'Ray Nicholus',
3    address: '1313 Mockingbird Lane',
4    city: 'Mockingbird Heights',
5    state: 'California',
6    sex: 'male',
7    age: 35
8  };

```

jQuery 提供了一个 API 方法来非常有效地处理这个问题- `$.extend()`:

```js
1  var user = $.extend(userLocation, userPersonal);

```

所以现在我们有了一个用户对象，它具有来自两个初始用户对象的属性。合并两个对象的能力在没有 jQuery 的情况下也是可能的(不足为奇——否则我为什么要开始描述对象合并呢？)虽然有一个非常优雅的方法，类似于 jQuery 的`extend()`(我将很快演示它)，但广泛的浏览器支持(目前)只有通过更冗长的解决方案才有可能。实际上，我们必须自己编写穷人的`extend()`方法来支持所有浏览器:

```js
1  function extend(first, second) {
2    for (var secondProp in second) {
3      var secondVal = second[secondProp];
4      first[secondProp] = secondVal;
5    }
6    return first;
7  }
8
9  var user = extend(userLocation, userPersonal);

```

另一种更简单的方法需要`Object.assign()`，这是 ECMAScript 2015 中首次添加到语言中的: <sup>20</sup>

```js
1  var user = Object.assign(userLocation, userPersonal);

```

很棒，但是没有任何版本的 Internet Explorer 支持它。在 Internet Explorer 11 被 Microsoft Edge 完全取代之前，您将需要依赖 polyfill 来提供在所有浏览器中访问这一语言功能。不过不用担心，有几个非常小的 polyfills 就足够了。

对于所有前面的代码示例(jQuery 和非 jQuery ),一个有效的关注点是第一个对象`userLocation`被修改为来自`userPersonal`的属性。`$.extend()`、我们的自定义`extend()`方法和`Object.assign()`的返回值是传递给每个函数的第一个对象。那么，我们如何在不修改任何一个对象的情况下创建一个包含两个合并的用户对象的新对象呢？简单:我们需要创建第一个对象的副本，然后将第二个对象合并到该副本中。

使用 jQuery 的`extend`方法，我们可以简单地将第一个参数(“目标”对象)声明为一个空对象。由于`$.extend()`采用可变数量的参数，我们可以指定两个初始用户对象作为后续参数:

```js
1  var user = $.extend({}, userLocation, userPersonal);

```

我们之前编写的自定义函数`extend`可以用来产生完全相同的结果。记住，我们需要创建第一个用户对象的副本，然后将第二个对象合并到这个副本中:

```js
1  var user = extend(extend({}, userLocation), userPersonal);

```

嵌套的`extend()`调用导致`userLocation`的副本作为外部`extend`的第一个参数，这正是我们基于两个原始用户对象创建一个全新对象所需要做的。

JavaScript 的最新版本`Object.assign()`，和 jQuery 的`extend`一样简洁优雅地解决了这个问题:

```js
1  var user = Object.assign({}, userLocation, userPersonal);

```

## 用数组解决问题

与上一节关于对象的内容类似，在这一节中，您将学习如何复制、解析和创建数组。记住数组是对象。也就是说，它们继承了在`Object.prototype`上定义的所有方法/属性。 <sup>21</sup> 但是`Array`对象自己定义了一些独特的方法，比如`forEach()`、`map()`、`concat()`、`indexOf()`、`find()`等等。我将向您介绍其中的一些方法，并演示如何复制一些流行的特定于数组的 jQuery API 方法的结果。

### 迭代数组项

在没有任何科学数据来支持这一断言(或寻找这种统计数据的动机)的情况下，我会说，根据我自己作为开发人员的经验，迭代数组中的项目是软件项目中最常见和最基本的模式之一。正如所料，jQuery 有一个迭代数组(和对象)的方法— `$.each()`:

```js
1  var languages = ['C', 'JavaScript', 'Go'];
2
3  $.each(languages, function(index, language) {
4    // ...

5  });

```

该循环将执行三次，对每个数组元素执行一次。对于每次迭代，`index`将分别为:`0`、`1`和`2`。类似地，`language`值将是`"C"`、`"JavaScript"`和`"Go"`。您可能很熟悉 jQuery，所以这并不奇怪。也许您已经知道如何不用 jQuery 迭代数组元素。但是，您可能不熟悉最现代的数组迭代方法，并且您可能不知道在处理数组时不应该使用的一种特殊类型的循环机制。我接下来会谈到所有这些。

当试图迭代任何东西时，许多开发人员可能会利用传统的`for`循环。尤其是如果你有 C/C++或受 C 语言影响的语言的工作经验，比如 Java、PHP 或 Perl(仅举几个例子)。使用 C 循环迭代我们的语言数组所需的代码如下所示(适用于所有浏览器):

```js
1  var languages = ['C', 'JavaScript', 'Go'];
2
3  for (var index = 0; index < languages.length; index++) {
4    var language = languages[index];
5    // ...

6  }

```

前面循环的另一个优点(除了熟悉之外)是浏览器支持。JavaScript 一直支持 c 循环。但是显然这种方法不如 jQuery 的`each()`方法优雅。在我们的“本地”解决方案中有一些看似不必要的样板文件。幸运的是，ECMAScript 5 在`Array.prototype`上定义了一个新方法:`forEach()`。 <sup>22</sup> 它的行为与 jQuery 的`each()`完全一样，只是有一个更吸引人的 API:

```js
1  var languages = ['C', 'JavaScript', 'Go'];
2
3  languages.forEach(function(language) {
4    // ...

5  });

```

你能指出`forEach()`比`$.each()`提供的两个改进吗？

1.  更直观的语法。您可以直接在数组上调用 loop 方法，而不是将数组传递给实用函数。
2.  “当前项”参数是传递给回调函数的第一个参数。反正这通常是你最感兴趣的。有时候，数组索引并不重要。

这两项改进还消除了冗余代码，使循环更具可读性。但是您可能想知道，“为什么不直接使用 for。。。在循环？”当然，这是上一节中处理对象时相当优雅的解决方案。但是使用 for 时存在一个隐患。。。当试图迭代`Array`元素时，在循环中。for 遍历的元素的顺序。。。不保证在循环中。换句话说，你的理由是可以想象的。。。例如，in 循环可能在第一项之前遇到第二项。如果顺序很重要，这可能会在代码中导致意想不到的结果，这是一个合理的假设，因为数组是用来以特定的顺序存储数据的。另一个问题:对于。。。in 循环将包含属于目标对象(在本例中是一个数组对象)的所有属性。因此，如果一个自定义属性被添加到`Array`实例中，它将意外地包含在索引值中。总之，不要用 for。。。在循环中迭代数组。还有很多其他更安全的选择。

一个更现代的本机循环机制是 for，它适用于除 IE 之外的现代浏览器。。。of 循环，首先在 ECMAScript 6 中定义: <sup>23</sup>

```js
1  var languages = ['C', 'JavaScript', 'Go'];
2
3  for (var language of languages) {
4    // ...

5  }

```

在这种情况下，`languages`数组中的每个元素都将按照预期的顺序出现。这是因为。。。of 循环调用一个存在于`Array.prototype`上的特殊迭代器方法。这个迭代器方法也是在 ES6、 <sup>24</sup> 中首次定义的，并且出现在其他可迭代类型上，包括`Set`、`Map`，甚至`NodeList`(由`querySelectorAll()`返回)。

### 定位特定项目

能够遍历数组中的项目为其他可能性打开了大门，比如过滤和搜索。本章讨论的所有方法——jQuery 和非 jQuery——都只是传统循环的包装器。但是这些更集中的函数使得搜索和过滤数组更加直观。

幸运的是，jQuery 将自己的两个 API 方法专用于搜索和过滤。首先说一下`$.inArray()`，这是一个返回匹配元素索引的方法(如果找不到匹配，则返回–1)。考虑以下阵列:

```js
1  var names = [
2    'Joe',
3    'Jane',
4    'Jen',
5    'Jim',
6    'Bill',
7    'Beth'
8  ];

```

如果我们想定位“Jen”的位置，我们可以很容易地使用 jQuery 的`inArray()`方法:

```js
1  // returns 2

2  $.inArray('Jen', names);

```

如果没有 jQuery，在不编写自己的助手函数的情况下，就没有在古代浏览器中搜索数组的好方法，例如:

```js
 1  function inArray(value, array) {
 2    var foundIndex = -1;
 3    for (var index = 0; index < array.length; index++) {
 4      if (array[index] === value) {
 5        foundIndex = index;
 6        break;

 7      }
 8    }
 9    return foundIndex;
10  }
11
12  // returns 2

13  inArray('Jen', names);

```

幸运的是，现代浏览器在`Array.prototype` : <sup>25</sup> 上使用 ES5 的`indexOf()`方法要简单一些

```js
1  // returns 2

2  names.indexOf('Jen');

```

就像`Array.prototype.forEach()`，`indexOf()`提供了比 jQuery 的`$.inArray()`更优雅的接口，并解决了完全相同的问题。但是现代浏览器对数组的支持远不止于此。假设您不寻找特定的值，但是您需要收集一些关于您的阵列的信息。假设您想知道`names`数组中是否至少有一个值以字母“B”开头。`Array.prototype.some()`允许你传递一个函数来测试数组的元素。条件一满足，该方法就返回`true`。否则，一旦所有数组项用尽，将返回`false`:

```js
1  // returns true

2  names.some(function(name) {
3    return name[0] === 'B';
4  });

```

请注意我们是如何将字符串文字作为数组来处理的。ECMAScript 5 首先规范了这种行为，所有现代浏览器都支持这种行为。但是字符串不是真正的数组，它是一个“伪数组”稍后会详细介绍。类似地，如果每个数组项都匹配通过的测试函数，`Array.prototype.every()`将返回`true`。这也是 ECMAScript 5 的一种方法，所有现代浏览器都支持。

ECMAScript 2015 提供了`Array.prototype.findIndex()` <sup>26</sup> 和`Array.prototype.find()` <sup>27</sup> 。前者将返回与通过的测试函数匹配的数组项的索引，后者将返回实际匹配的数组项，对于除 IE 之外的现代桌面浏览器和部分移动浏览器:

```js
1  // returns 4

2  names.findIndex(function(name) {
3    return name[0] === 'B';
4  });
5
6  // returns "Bill"

7  names.find(function(name) {
8    return name[0] === 'B';
9  });

```

截至 2016 年年中，`find()`和`findIndex()`的浏览器支持有些有限。在已经拥挤的数组方法组中，ECMAScript 2016 提供了另一种方法来确定特定元素是否存在于数组中。我们可以使用`Array.prototype.includes()` <sup>28</sup> 更优雅地判断一个或多个数组项是否为“Bill”，对于除 IE 和 Edge 之外的现代桌面浏览器，以及除 IE 之外的所有移动浏览器:

```js
1  // returns true

2  names.includes("Bill");

```

可以说，这些新方法中有许多是不必要的，实际上只节省了一两行代码，但是它们的出现说明了这种语言在响应 jQuery 等库方面的快速发展。

jQuery 提供的另一个特定于数组的 API 方法是`$.grep()`，它搜索一个数组并返回匹配一个测试函数的所有项。使用我们的`names`数组，您可以使用`$.grep()`来定位所有正好三个字符长的项目:

```js
1  // returns ["Joe", "Jen", "Jim"]

2  $.grep(names, function(name) {
3    return name.length === 3;
4  });

```

ECMAScript 5 提供了一个`Array.prototype.filter()`来解决现代浏览器中同样的问题:

```js
1  // returns ["Joe", "Jen", "Jim"]

2  names.filter(function(name) {
3    return name.length === 3;
4  });

```

尽管 jQuery 版中已经有了很多这样的实用函数，但是 JavaScript 已经走过了很长的路。这种语言不仅提供了这些 jQuery 函数的本地实现，甚至还提供了额外的方法，这些方法提供了比 jQuery API 中的任何东西都更多的功能。

### 管理伪阵列

在 JavaScript 中，有真实的数组:

```js
1  var realArray = ['a', 'b', 'c'];

```

。。。和“伪数组”:

```js
1  var pseudoArray = {
2    0: 'a',
3    1: 'b',
4    2: 'c',
5    length: 3
6  };

```

还有一些本机伪数组，例如`NodeList`、、 <sup>29</sup> `HTMLCollection`、 <sup>30</sup> 和`FileList`、 <sup>31</sup> 等等。伪数组不是真正的数组，因为它们和`Array`不在同一个原型链上。也就是说，它们没有从`Array.prototype`继承任何东西，因为它们不是数组。事实上，它们只是普通的老物件。但是，由于它们的`length`属性，在某些方面，您可以将它们视为一个数组。例如，您可以使用 C-loop 迭代它们的“元素”，就像您对任何真实数组所做的那样。

当在一个古老的浏览器中处理伪数组时，它不是从`Array.prototype`继承的这个事实可能并不重要，因为无论如何你都需要使用一个传统的`for`循环来迭代这些项。但是，假设您使用的是现代浏览器，并且您想让这个看起来非常像数组的对象表现得像数组一样。也许你想使用`forEach()`，或者`map()`，或者`filter()`，或者我在这一节已经介绍过的任何其他数组方法。或者你需要把它传递给一个 API 方法，该方法需要一个真实的数组。

您可以在 jQuery 中使用`$.makeArray();`将伪数组转换为真实数组

```js
1  var realArray = $.makeArray(pseudoArray);
2
3  // now you can call all methods available on Array.prototype:

4  realArray.forEach(function(element, index) {
5    // ...

6  });

```

如果您想在不使用 jQuery 的情况下将伪数组转换为真正的数组，可以使用以下技巧:

```js
1  var realArray = [].slice.call(pseudoArray);
2
3  // now you can call all methods available on Array.prototype:

4  realArray.forEach(function(element, index) {
5    // ...

6  });

```

真实世界的场景可能需要您选择一组元素并对它们进行迭代，或者甚至收集那些满足特定标准的元素。想象一下选择所有文本输入并排除那些空的:

```js
1  var textInputs = document.querySelectorAll('INPUT[type="text"]');
2  var textInputsArray = [].slice.call(textInputs);
3  var nonEmptyFields = textInputsArray.filter(
4    function(input) {
5      return input.value.length > 0;
6    }
7  );

```

为什么会这样？`Array.prototype`上的`slice()`方法只期望它正在操作的对象具有数字属性和`length`属性。因此，通过将对`slice()`的调用的上下文更改为伪数组，我们最终得到了一个真正的数组作为交换。这也是有效的，因为`Array.prototype.slice()`在没有参数的情况下被调用时，只是返回一个新的`Array`。

前面的“技巧”看起来更像是一种黑客行为，尽管它可以可靠地跨浏览器工作。从 ECMAScript 2015 开始，我们在`Array`对象上有了一个官方方法，将伪数组转换为真实数组:`Array.from()`:

```js
1  var realArray = Array.from(pseudoArray);
2
3  // now you can call all methods available on Array.prototype:

4  realArray.forEach(function(element, index) {
5    // ...

6  });

```

不那么令人讨厌，但不幸的是，Internet Explorer 或大多数移动浏览器都不支持这种方法。随着时间的推移，这将不再是一个问题。同时，如果您想在不使用 jQuery 的情况下使用伪数组，前面演示的跨浏览器代码是有效且简单的。

### 映射和合并

这里，看看这一系列的名字:

```js
1  var names = [
2    'ray',
3    'kat',
4    'mark',
5    'emily'
6  ];

```

你注意到这些名字有什么问题吗？名称是英语中的专有名词，因此应该以大写字母开头，但是我们数组中的所有名称都以小写字母开头。也许这些名字不是用来展示的。解决这个问题的一种方法是创建一个新数组，每个名称都要有适当的大小写。jQuery 的`map()`函数允许我们这样做——基于现有数组创建一个新数组:

```js
1  // properNames will contain properly-cased names after execution

2  var properNames = $.map(names, function(name) {
3    return name[0].toUpperCase() + name.slice(1);
4  });

```

在古老的浏览器中，我们必须创建一个新的空数组，使用 C 循环迭代 names 数组的值，并将每个大小写正确的名字推送到新的`properNames`数组中。这并不难，但是如果有更好的解决方案(不使用 jQuery)就更好了。ECMAScript 5 给了我们一个原生的解决方案:`Array.prototype.map()`:32

```js
1  // properNames will contain properly-cased names after execution

2  var properNames = names.map(function(name) {
3    return name[0].toUpperCase() + name.slice(1);
4  });

```

将一个数组映射到一个新数组显然是有用的，但是如果我们想要组合两个数组呢？和往常一样，jQuery 为这个特定的目的提供了一种方法:名为`merge()`。让我们使用 jQuery 的`merge()`方法来组合两个用户数组。这些数组中的每一个都代表来自不同系统的一组用户，我们希望在单个数组中考虑每一组用户。

这两个数组如下所示:

```js
 1  var users1 = [
 2    {name: 'Ray'},
 3    {name: 'Kat'},
 4    {name: 'Mark'}
 5  ];
 6
 7  var users2 = [
 8    {name: 'Emily'},
 9    {name: 'Joe'},
10    {name: 'Huang'}
11  ];

```

我们的 jQuery 代码如下:

```js
1  // users1 will contain all users1 user and

2  // all users2 users after this completes

3  $.merge(users1, users2);

```

现在我们有了一个包含两组用户的数组，但是我们也修改了其中一个原始数组(`users1`)。我们可能不想这么做。相反，创建一个合并了`users1`和`users2`内容的新数组可能更明智。虽然`$.merge()`并没有考虑到这个特定的场景，但它仍然是可能的，尽管这个解决方案并不特别优雅:

```js
1  // users3 will contain all users1 user and

2  // all users2 users after this completes

3  var users3 = $.merge($.merge([], users1), users2);

```

您也可以使用本机的`Array.prototype.concat()`方法将两个数组合并成一个新数组:

```js
1  // users3 will contain all users1 user and

2  // all users2 users after this completes

3  var users3 = users1.concat(users2);

```

这不仅比使用 jQuery 简单得多，而且所有浏览器都支持它。但是让我们说，为了便于讨论，你真的想将所有来自`users2`的条目合并到`users1`中。在这个特定的(可能不常见的)场景中，jQuery 的`merge()`方法在简单性方面胜出，但是您仍然可以使用 TC39 小组提供的工具来完成这个任务，而不会有太大的麻烦: <sup>33</sup>

```js
1  // users1 will contain all users1 user and

2  // all users2 users after this completes

3  users2.forEach(function(user) {
4    users1.push(user);
5  });

```

通过使用标准的 C 循环代替`Array.prototype.forEach()`，我们也可以让前面的代码在古老的浏览器中工作。

但是还有一个选择！ECMAScript 2015 定义了一个新的“spread”运算符 <sup>34</sup> ，可用于(除其他外)组合两个数组，适用于除 IE 以外的浏览器:

```js
1  // users3 will contain all users1 user and

2  // all users2 users after this completes

3  var users3 = [...users1, ...users2];

```

上述内容在功能上等同于我们之前使用的`Array.prototype.concat()`。`users3`数组包含其他两个用户数组的值，并且对`users1`或`users2`没有任何改变。

## 有用的函数技巧

有许多有趣的方法可以让 JavaScript 数组和对象为您解决问题并满足您项目的需求。在前面的章节中，我们已经走过了许多这样的例子。我已经介绍了一般的`Object`和`Array`对象，但是我还没有介绍一个更重要的`Object`类型:`function` s！没错，JavaScript 函数也是对象。

在这最后一节中，您将学习如何创建新函数、更改现有函数的上下文，甚至创建一个新函数来调用带有一组默认参数的旧函数。jQuery 为所有这些提供了一些支持，但是，和往常一样，有效地使用函数所需的所有功能都存在于底层语言(JavaScript)中。

### 关于 JavaScript 上下文的一句话

有许多重要的概念，JavaScript 和前端开发人员必须了解才能有效。虽然我的意图不是在本书中涵盖所有这些概念，但我已经演示了相当多的概念。在这一节中，我将关注另一个重要的语言特性:上下文。

在 JavaScript 中，在代码执行期间的任何给定时间，上下文决定了关键字`this`的值。对于一个经常被混淆和误解的概念，这是一个非常简单的解释。一个常见的错误是混淆了范围和上下文，或者忽略了范围和上下文之间的区别。可以说，范围和上下文是两个完全不同的概念。上下文处理的是`this`，而作用域描述的是在特定的点上哪些变量是可访问的。在 ECMAScript 2015 之前，JavaScript 只支持函数作用域。现在，随着`const`和`let`关键字的引入，块范围也终于可用了。

我认为解释上下文的最好方法是通过代码示例。接下来，我将举例说明三种不同的常见场景，其中`this`的值不同。这并不意味着对上下文的完整和详尽的讨论，而是一些信息，以消除该主题的一些复杂性，并让您获得更好的整体理解。

在第一个例子中，函数中的值`this`将是“全局”对象。在浏览器中，这个全局对象是`window`，在服务器上(带有 Node.js)这个值是`global`对象。

```js
1  function printThis() {
2    console.log(this);
3  }
4
5  printThis();

```

该代码将把`window`或`global`对象记录到控制台。但是有一点问题。如果该代码在“严格”模式下执行，`this`的值将为`undefined`。要在严格模式下执行相同的代码，我们需要做的就是将“使用严格”pragma 添加到我们的`printThis()`函数的顶部:

```js
1  function printThis() {
2    'use strict';
3    console.log(this);
4  }
5
6  printThis();

```

而现在，`undefined`登录到控制台。ECMAScript 5 中首次引入了严格模式。 <sup>35</sup> 虽然我不打算在本书中谈论更多，但可以说严格模式试图防范一些潜在的危险编码错误，例如依赖独立函数内的`this`的值或试图覆盖`arguments`伪数组。浏览器对严格模式的支持仅限于现代浏览器，Internet Explorer 9 除外。

JavaScript 中上下文的第二个例子涉及执行作为对象属性的函数。您认为下面的代码片段会打印到控制台上吗？

```js
1  var person = {
2    name: 'Ray',
3    printName: function() {
4      console.log(this.name);
5    }
6  }
7
8  person.printName();

```

如果你猜对了“雷”。当一个函数属于一个对象时，该函数的上下文被绑定到父对象。在这种情况下，严格模式不会改变上下文。在某些方面，这与前面的例子没有什么不同。因为所有的“孤儿”函数都属于`global`或`window`对象，所以这些函数的上下文必然会绑定到`window` / `global`对象，至少为了一致性。

上下文的第三个也是最后一个例子与构造函数有关。构造函数代表一个可以使用关键字`new`创建的对象。考虑下面的构造函数和一些构建关联对象的新实例的代码。也许您可以猜到控制台上会打印出什么内容:

```js
1  var Person = function(name) {
2    console.log(name + ' lives in the ' + this.country);
3  };
4  Person.prototype.country = 'United States';
5
6  var rayPerson = new Person('Ray');

```

剧透警告:执行前面的代码会将“Ray lives in the United States”打印到控制台上。但是为什么呢？`Person`是一个“孤儿”函数，不是吗？是的，是的，如果我们从最后一行中删除了关键字`new`，我们的代码片段将以`var rayPerson = Person('Ray')`结束，而`this.country`将是`undefined`(当然，除非其他一些代码事先给`window` / `global`对象添加了一个`country`属性)。当一个函数被“构造”时，该函数的上下文被绑定到相应的对象。在本例中，这是一个`Person`对象，在其原型链上有一个`country`属性。

关于这个构造函数的另一个问题是:为什么构造函数名的第一个字母是大写的？这与范围完全无关，但仍然是一个公平的问题。按照惯例，构造函数的名字是大写的。当这个约定被一致地遵循时，开发人员就更容易区分应该使用`new`关键字构造的对象和不应该构造的对象。如果一个应该使用`new`创建的对象没有以这种方式创建，可能会出现意外的行为。

### 从旧函数创建新函数

了解上下文如何分配给一个函数的细节是有用的，但这些并不是一成不变的规则。不，一点也不。可以为任何函数任意指定上下文。首先，您可以从现有函数创建一个新函数，并使用备用上下文初始化这个新函数。jQuery 为此提供了`$.proxy()`:

```js
 1  var person = {
 2    name: 'Ray',
 3    handleClick: function() {
 4      console.log(this.name + ' was clicked');
 5    }
 6  }
 7
 8  $('#my-person').click(
 9    $.proxy(person.handleClick, person)
10  );

```

当点击 ID 为“my-person”的元素(大概是一个`<button>`)时，“Ray 被点击”将被打印到控制台。如果我们删除了`$.proxy()`调用，结果将会是“undefined 被点击”。但是为什么呢？属于`person`对象的`handleClick()`函数不是应该默认接收`person`作为它的上下文吗？是的，默认情况下会，但是`handleClick()`不是普通的函数——它是一个事件处理器。浏览器会自动将所有事件处理程序的上下文设置为目标元素。在这种情况下，这将是“点击”的元素，这不是我们想要的。因此，我们需要创建一个新的函数，使用`person`对象作为它的上下文，这样我们就可以在处理点击事件时记录这个人的名字。正如您之前看到的，jQuery 的`proxy()` API 方法提供了实现这一点的方法。

在 ECMAScript 5 出现并创建了`Function.prototype.bind()`方法之前，jQuery 的`proxy()`方法非常有用和优雅。 <sup>36</sup> 在支持`bind()`之前，需要一个令人眼花缭乱的 polyfill 来实现相同的行为，或者你可以简单地引入 jQuery 并继续为你的项目编码。幸运的是，所有现代浏览器都支持`bind()`，对于现代浏览器来说，前面的例子可以在没有 jQuery 和包装器的情况下复制:

```js
 1  var person = {
 2    name: 'Ray',
 3    handleClick: function() {
 4      console.log(this.name + ' was clicked');
 5    }
 6  };
 7
 8  document.getElementById('my-person').addEventListener(
 9    'click',
10    person.handleClick.bind(person)
11  );

```

奇妙——我们可以改变事件处理程序的上下文来匹配持有这些函数的对象，反映我们对绑定到对象的函数属性的期望。但是如果我们需要做得更多呢？当处理函数被绑定时，如果我们需要向这个事件处理程序提供特定的参数怎么办？假设句柄还需要知道它所绑定的对象之外的环境的一些细节。在我们的例子中，`person.handleClick()`函数还需要有一个当前登录用户的句柄。使用 jQuery 的`proxy()`函数，我们可以简单地通过将用户信息作为附加参数传递给上下文参数之后来满足这个新需求:

```js
 1  var person = {
 2    name: 'Ray',
 3    handleClick: function(user) {
 4      console.log(this.name + ' was clicked by ' + user);
 5    }
 6  };
 7
 8  $('#my-person').click(
 9    $.proxy(person.handleClick, person, 'Kat')
10  );

```

我们也可以用`Function.prototype.bind()`来做这件事！

```js
 1  var person = {
 2    name: 'Ray',
 3    handleClick: function(user) {
 4      console.log(this.name + ' was clicked by ' + user);
 5    }
 6  };
 7
 8  document.getElementById('my-person').addEventListener(
 9    'click',
10    person.handleClick.bind(person, 'Kat')
11  );

```

同样，与`$.proxy()`示例一样，前面的代码将“Ray 被 Kat 点击”打印到控制台。我怀疑你们中的一些人想知道通常作为第一个参数传递给事件处理函数的`Event`对象参数发生了什么。它仍然在那里，并且由浏览器传递给我们的事件处理程序。还记得我们用`bind`创造的新功能吗？我们坚持让我们的新函数接收一个参数“Kat”这将始终是我们的新函数收到的第一个参数，使`Event`对象排在第二位。如果我们在调用`bind()`时传递了两个新参数，`Event`将会是第三个参数。jQuery 的`proxy()`方法也是如此。

### 用新上下文调用现有函数

除了创建一个全新的函数之外，还有一种方法可以改变上下文并增加参数。相反，您可能更喜欢按需调用原始函数，并在调用时指定新的上下文(和可选的参数)。jQuery 没有提供任何方法来实现这一点，这可能是因为 JavaScript 在早期就支持这种行为。

JavaScript 的第一个版本包含了`Function.prototype.call()`，它允许使用可选的上下文调用任意函数。让我们重写第一个普通的 JavaScript `person`事件处理程序，它用`call`代替`bind`:

```js
 1  var person = {
 2    name: 'Ray',
 3    handleClick: function() {
 4      console.log(this.name + ' was clicked');
 5    }
 6  };
 7
 8  document.getElementById('my-person').addEventListener(
 9    'click',
10    function() {
11      person.handleClick.call(person);
12    }
13  );

```

我们不是基于`person.handleClick()`函数创建一个新函数，而是向`addEventListener()`提供一个函数，当通过点击动作执行时，该函数调用上下文为`person`的`person.handleClick()`函数。结果和我们之前的`bind`例子一样，但是方法有点不同。在引入`bind`之前，以这种方式使用`call`是使用 polyfill 或引入 jQuery 来利用`$.proxy()`的一种替代方法。

与`bind()`一样，`call()`方法也提供了一种向目标函数提供额外参数的方式。因此，我们也可以使用`call()`重写第二个`bind()`示例:

```js
 1  var person = {
 2    name: 'Ray',
 3    handleClick: function(user) {
 4      console.log(this.name + ' was clicked by ' + user);
 5    }
 6  };
 7
 8  document.getElementById('my-person').addEventListener(
 9    'click',
10    function() {
11      person.handleClick.call(person, 'Kat');
12    }
13  );

```

与`bind()`一样，`call()`方法接受一个新的上下文作为第一个参数，并接受一组以逗号分隔的初始参数传递给目标函数。这个逗号分隔的列表成为目标函数可用的`arguments`伪数组。在我们的例子中，传递给初始事件处理函数的参数被完全忽略了(对象`Event`)——它没有传递给`handleClick()`函数。这是`call()`与`bind()`的另一个不同之处。在需要将单个已知参数传递给目标函数的情况下，这是理想的。但是，如果中间函数必须充当目标函数的简单代理，传递逗号分隔的参数列表的要求就成了一个限制。

想象一个被设计用来记录函数调用的函数。它不想也不需要知道太多关于目标函数的信息。它的工作很简单:拦截函数调用，记录它，然后将控制传递给目标函数。为了正确地完成这一壮举，我们必须能够将整个`arguments`伪数组传递给目标函数。为此，我们必须使用`Function.protoype.apply()`，它允许我们传递一个数组或类似数组的对象，以及目标函数的上下文:

```js
 1  var person = {
 2    name: 'Ray',
 3    handleClick: function(user) {
 4      console.log(this.name + ' was clicked by ' + user);
 5    }
 6  };
 7
 8  function logFunctionCall(targetFunction) {
 9    // We need to pass only the "original" arguments, which means

10    // we have to slice off the first one passed to this function,

11    // and remember `arguments` is a pseudo-array!

12    var originalArguments = [].slice.call(arguments, 1);
13
14    console.log('Calling ' + targetFunction.toString() +
15      ' with ' + originalArguments);
16
17    targetFunction.apply(this, originalArguments);
18  }
19
20  document.getElementById('my-person').addEventListener(
21    'click',
22    logFunctionCall.bind(person, person.handleClick, 'Kat')
23  );

```

在我们最初的事件处理程序中，为了简单起见，我们使用`bind()`来调用我们的中间日志记录函数。log()函数的上下文将是`person`对象。这将使 log()函数更容易盲目地调用具有所需上下文的目标函数。当然，我们需要向`handleClick()`函数提供当前用户名，以便将其传递给 log()函数，以及对`handleClick()`函数的“引用”。

当调用`logFunctionCall()`函数作为处理 click 事件的一部分时，目标函数源和和目标参数被记录到控制台，然后使用提供给原始调用函数的任何参数调用目标函数。在这种情况下，这将确保用户名“Kat”和代表点击事件的`MouseEvent`对象实例都被传递给`person.handleClick()`函数。由于`logFunctionCall`的上下文已经绑定到了`person`对象，我们可以在调用目标函数时使用`this`作为所需的上下文。

最后一个例子比前面的一些例子稍微复杂一些，但是它说明了强大的 API 的一个重要的真实世界的用法，这个 API 对于 web 开发人员来说是天生可用的。您可以断言对函数、数组、对象和原语的完全控制，而无需任何库的帮助。对这种语言的简单理解就足够了！

Footnotes 1

[`https://api.jquery.com/category/utilities/`](https://api.jquery.com/category/utilities/)

  2

[`www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262%2C`](http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262%2C)

  3

[`www.ecma-international.org/ecma-262/5.1/#sec-15.9.4.4`](http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.4.4)

  4

[`https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L453`](https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L453)

  5

[`www.ecma-international.org/ecma-262/5.1/#sec-15.12`](http://www.ecma-international.org/ecma-262/5.1/#sec-15.12)

  6

[`https://github.com/douglascrockford/JSON-js/blob/master/json2.js`](https://github.com/douglascrockford/JSON-js/blob/master/json2.js)

  7

[`https://msdn.microsoft.com/en-us/library/azure/dd179382.aspx`](https://msdn.microsoft.com/en-us/library/azure/dd179382.aspx)

  8

[`https://github.com/FineUploader/fine-uploader/blob/6aa179f7b009cb80376b997975a7acf35cc72635/client/js/azure/util.js#L78`](https://github.com/FineUploader/fine-uploader/blob/6aa179f7b009cb80376b997975a7acf35cc72635/client/js/azure/util.js#L78)

  9

[`www.w3.org/TR/DOM-Parsing/`](http://www.w3.org/TR/DOM-Parsing/)

  10

[`https://www.w3.org/TR/cssom-1/`](https://www.w3.org/TR/cssom-1/)

  11

[`www.ecma-international.org/ecma-262/5.1/#sec-15.5.4.20`](http://www.ecma-international.org/ecma-262/5.1/#sec-15.5.4.20)

  12

[`https://github.com/FineUploader/fine-uploader/blob/537a86bf3d6edd8068e66422a605b392dc8d0b1e/client/js/util.js#L292`](https://github.com/FineUploader/fine-uploader/blob/537a86bf3d6edd8068e66422a605b392dc8d0b1e/client/js/util.js#L292)

  13

[`https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)

  14

[`www.ecma-international.org/ecma-262/5.1/#sec-15.6.4.3`](http://www.ecma-international.org/ecma-262/5.1/#sec-15.6.4.3)

  15

[`www.ecma-international.org/ecma-262/5.1/#sec-4.3.11`](http://www.ecma-international.org/ecma-262/5.1/#sec-4.3.11)

  16

[`http://wiki.ecmascript.org/doku.php?id=harmony%3Atypeof_null`](http://wiki.ecmascript.org/doku.php?id=harmony%3Atypeof_null)

  17

[`www.ecma-international.org/ecma-262/5.1/#sec-15.4.3.2`](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.3.2)

  18

[`https://bugs.jquery.com/ticket/5499`](https://bugs.jquery.com/ticket/5499)

  19

[`www.ecma-international.org/ecma-262/5.1/#sec-15.2.3.14`](http://www.ecma-international.org/ecma-262/5.1/#sec-15.2.3.14)

  20

[`www.ecma-international.org/ecma-262/6.0/#sec-object.assign`](http://www.ecma-international.org/ecma-262/6.0/#sec-object.assign)

  21

[`www.ecma-international.org/ecma-262/6.0/#sec-properties-of-the-object-prototype-object`](http://www.ecma-international.org/ecma-262/6.0/#sec-properties-of-the-object-prototype-object)

  22

[`www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.18`](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.18)

  23

[`www.ecma-international.org/ecma-262/6.0/#sec-for-in-and-for-of-statements`](http://www.ecma-international.org/ecma-262/6.0/#sec-for-in-and-for-of-statements)

  24

[`www.ecma-international.org/ecma-262/6.0/#sec-symbol.iterator`](http://www.ecma-international.org/ecma-262/6.0/#sec-symbol.iterator)

  25

[`www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.14`](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.14)

  26

[`www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.findIndex`](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.findIndex)

  27

[`www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.find`](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.find)

  28

[`https://tc39.github.io/ecma262/#sec-array.prototype.includes`](https://tc39.github.io/ecma262/#sec-array.prototype.includes)

  29

[`https://developer.mozilla.org/en-US/docs/Web/API/NodeList`](https://developer.mozilla.org/en-US/docs/Web/API/NodeList)

  30

[`https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection)

  31

[`https://developer.mozilla.org/en-US/docs/Web/API/FileList`](https://developer.mozilla.org/en-US/docs/Web/API/FileList)

  32

[`www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.19`](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.19)

  33

[`www.ecma-international.org/memento/TC39.htm`](http://www.ecma-international.org/memento/TC39.htm)

  34

[`www.ecma-international.org/ecma-262/6.0/#sec-array-initializer`](http://www.ecma-international.org/ecma-262/6.0/#sec-array-initializer)

  35

[`www.ecma-international.org/ecma-262/5.1/#sec-10.1.1`](http://www.ecma-international.org/ecma-262/5.1/#sec-10.1.1)

  36

[`www.ecma-international.org/ecma-262/5.1/#sec-15.3.4.5`](http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.4.5)